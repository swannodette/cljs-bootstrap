;; Analyzed by ClojureScript 0.0-3423
{:use-macros nil, :excludes #{}, :name cljs.core, :imports {StringBuffer goog.string.StringBuffer}, :requires {gstring goog.string, goog.string goog.string, gobject goog.object, goog.object goog.object, garray goog.array, goog.array goog.array, StringBuffer goog.string.StringBuffer}, :uses nil, :defs {->PersistentHashSet {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7774, :column 10, :end-line 7774, :end-column 27, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :factory :positional, :arglists (quote ([meta hash-map __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/->PersistentHashSet, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([meta hash-map __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7774, :end-line 7774, :max-fixed-arity 3, :fn-var true, :arglists (quote ([meta hash-map __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, js->clj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9120, :column 7, :end-line 9120, :end-column 14, :arglists (quote ([x] [x & opts])), :doc "Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option ':keywordize-keys true' will convert object fields from\n  strings to keywords.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([x]), :arglists ([x] [x & opts]), :arglists-meta (nil nil)}}, :name cljs.core/js->clj, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([x]), :arglists ([x] [x & opts]), :arglists-meta (nil nil)}, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9120, :end-line 9120, :max-fixed-arity 1, :fn-var true, :arglists ([x] [x & opts]), :doc "Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option ':keywordize-keys true' will convert object fields from\n  strings to keywords."}, sort-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2086, :column 7, :end-line 2086, :end-column 14, :arglists (quote ([keyfn coll] [keyfn comp coll])), :doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([keyfn coll] [keyfn comp coll]), :arglists ([keyfn coll] [keyfn comp coll]), :arglists-meta (nil nil)}}, :name cljs.core/sort-by, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([keyfn coll] [keyfn comp coll]), :arglists ([keyfn coll] [keyfn comp coll]), :arglists-meta (nil nil)}, :method-params ([keyfn coll] [keyfn comp coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2086, :end-line 2086, :max-fixed-arity 3, :fn-var true, :arglists ([keyfn coll] [keyfn comp coll]), :doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare."}, ITransientAssociative {:meta {:file "cljs/core.cljs", :line 639, :column 14, :end-line 639, :end-column 35, :doc "Protocol for adding associativity to transient collections.", :protocol-symbol true, :protocol-info {:methods {-assoc! [[tcoll key val]]}}}, :protocol-symbol true, :name cljs.core/ITransientAssociative, :file "cljs/core.cljs", :end-column 35, :column 1, :line 639, :protocol-info {:methods {-assoc! [[tcoll key val]]}}, :info nil, :end-line 639, :impls #{cljs.core/TransientVector cljs.core/TransientHashMap cljs.core/TransientArrayMap}, :doc "Protocol for adding associativity to transient collections."}, chunk-first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3132, :column 7, :end-line 3132, :end-column 18, :arglists (quote ([s]))}, :name cljs.core/chunk-first, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3132, :end-line 3132, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, m3-hash-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 775, :column 15, :end-line 775, :end-column 26, :tag number, :arglists (quote ([in]))}, :name cljs.core/m3-hash-int, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([in]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 775, :ret-tag number, :end-line 775, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([in]))}, stepper {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3536, :column 7, :end-line 3536, :end-column 14, :arglists (quote ([xform iter]))}, :name cljs.core/stepper, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([xform iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3536, :end-line 3536, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform iter]))}, pr-str* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 723, :column 7, :end-line 723, :end-column 14, :arglists (quote ([obj])), :doc "Support so that collections can implement toString without\n   loading all the printing machinery."}, :name cljs.core/pr-str*, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 723, :end-line 723, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj])), :doc "Support so that collections can implement toString without\n   loading all the printing machinery."}, eduction {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9063, :column 7, :end-line 9063, :end-column 15, :arglists (quote ([xform* coll])), :doc "Returns a reducible/iterable application of the transducers\n  to the items in coll. Transducers are applied in order as if\n  combined with comp. Note that these applications will be\n  performed every time reduce/iterator is called.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(xforms)], :arglists ([& xforms]), :arglists-meta (nil)}}, :name cljs.core/eduction, :variadic true, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(xforms)], :arglists ([& xforms]), :arglists-meta (nil)}, :method-params [(xforms)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9063, :end-line 9063, :max-fixed-arity 0, :fn-var true, :arglists ([& xforms]), :doc "Returns a reducible/iterable application of the transducers\n  to the items in coll. Transducers are applied in order as if\n  combined with comp. Note that these applications will be\n  performed every time reduce/iterator is called."}, tree-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4390, :column 7, :end-line 4390, :end-column 15, :arglists (quote ([branch? children root])), :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n   branch? must be a fn of one arg that returns true if passed a node\n   that can have children (but may not).  children must be a fn of one\n   arg that returns a sequence of the children. Will only be called on\n   nodes for which branch? returns true. Root is the root node of the\n  tree."}, :name cljs.core/tree-seq, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([branch? children root]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4390, :end-line 4390, :max-fixed-arity 3, :fn-var true, :arglists (quote ([branch? children root])), :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n   branch? must be a fn of one arg that returns true if passed a node\n   that can have children (but may not).  children must be a fn of one\n   arg that returns a sequence of the children. Will only be called on\n   nodes for which branch? returns true. Root is the root node of the\n  tree."}, unchecked-remainder-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2384, :column 7, :end-line 2384, :end-column 30, :arglists (quote ([x n]))}, :name cljs.core/unchecked-remainder-int, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2384, :end-line 2384, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n]))}, uuid {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9640, :column 7, :end-line 9640, :end-column 11, :arglists (quote ([s]))}, :name cljs.core/uuid, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9640, :end-line 9640, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1022, :column 12, :end-line 1022, :end-column 15, :tag seq, :arglists (quote ([coll])), :doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings."}, :name cljs.core/seq, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1022, :ret-tag seq, :end-line 1022, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings."}, Volatile {:num-fields 1, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :name cljs.core/Volatile, :file "cljs/core.cljs", :end-column 18, :type true, :column 10, :line 3992, :record false, :end-line 3992, :skip-protocol-flag #{cljs.core/IDeref}}, reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2120, :column 7, :end-line 2120, :end-column 13, :arglists (quote ([f coll] [f val coll])), :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f val coll]), :arglists ([f coll] [f val coll]), :arglists-meta (nil nil)}}, :name cljs.core/reduce, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f val coll]), :arglists ([f coll] [f val coll]), :arglists-meta (nil nil)}, :method-params ([f coll] [f val coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2120, :end-line 2120, :max-fixed-arity 3, :fn-var true, :arglists ([f coll] [f val coll]), :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called."}, INIT {:name cljs.core/INIT, :file "cljs/core.cljs", :line 3485, :column 1, :end-line 3485, :end-column 10, :meta {:file "cljs/core.cljs", :line 3485, :column 6, :end-line 3485, :end-column 10}}, find-ns {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9928, :column 7, :end-line 9928, :end-column 14, :arglists (quote ([ns]))}, :name cljs.core/find-ns, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([ns]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9928, :end-line 9928, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ns]))}, contains? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1977, :column 16, :end-line 1977, :end-column 25, :tag boolean, :arglists (quote ([coll v])), :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'."}, :name cljs.core/contains?, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([coll v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1977, :ret-tag boolean, :end-line 1977, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([coll v])), :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'."}, every? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3687, :column 16, :end-line 3687, :end-column 22, :tag boolean, :arglists (quote ([pred coll])), :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false."}, :name cljs.core/every?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3687, :ret-tag boolean, :end-line 3687, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false."}, ->ES6IteratorSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1113, :column 10, :end-line 1113, :end-column 24, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}, :factory :positional, :arglists (quote ([value iter _rest]))}, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :name cljs.core/->ES6IteratorSeq, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([value iter _rest]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1113, :end-line 1113, :max-fixed-arity 3, :fn-var true, :arglists (quote ([value iter _rest])), :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}}, Var {:num-fields 3, :protocols #{cljs.core/IFn cljs.core/Object cljs.core/IMeta cljs.core/Fn cljs.core/IDeref}, :name cljs.core/Var, :file "cljs/core.cljs", :end-column 13, :type true, :column 10, :line 943, :record false, :end-line 943, :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IDeref}}, keep-indexed {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4014, :column 7, :end-line 4014, :end-column 19, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name cljs.core/keep-indexed, :variadic false, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4014, :end-line 4014, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided."}, ->PersistentQueueSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5290, :column 10, :end-line 5290, :end-column 28, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([meta front rear __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->PersistentQueueSeq, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([meta front rear __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5290, :end-line 5290, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta front rear __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}}, subs {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2580, :column 7, :end-line 2580, :end-column 11, :arglists (quote ([s start] [s start end])), :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([s start] [s start end]), :arglists ([s start] [s start end]), :arglists-meta (nil nil)}}, :name cljs.core/subs, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([s start] [s start end]), :arglists ([s start] [s start end]), :arglists-meta (nil nil)}, :method-params ([s start] [s start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2580, :end-line 2580, :max-fixed-arity 3, :fn-var true, :arglists ([s start] [s start end]), :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive."}, set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8005, :column 7, :end-line 8005, :end-column 10, :arglists (quote ([coll])), :doc "Returns a set of the distinct elements of coll."}, :name cljs.core/set, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8005, :end-line 8005, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a set of the distinct elements of coll."}, compare-indexed {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2040, :column 17, :end-line 2040, :end-column 32, :private true, :arglists (quote ([xs ys] [xs ys len n])), :doc "Compare indexed collection.", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([xs ys] [xs ys len n]), :arglists ([xs ys] [xs ys len n]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/compare-indexed, :variadic false, :file "cljs/core.cljs", :end-column 32, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([xs ys] [xs ys len n]), :arglists ([xs ys] [xs ys len n]), :arglists-meta (nil nil)}, :method-params ([xs ys] [xs ys len n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2040, :end-line 2040, :max-fixed-arity 4, :fn-var true, :arglists ([xs ys] [xs ys len n]), :doc "Compare indexed collection."}, take-last {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4228, :column 7, :end-line 4228, :end-column 16, :arglists (quote ([n coll])), :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec."}, :name cljs.core/take-last, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4228, :end-line 4228, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec."}, IndexedSeq {:meta {:file "cljs/core.cljs", :line 1005, :column 29, :end-line 1005, :end-column 39, :declared true}, :num-fields 2, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/IndexedSeq, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 1337, :record false, :declared true, :end-line 1337, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/ISequential cljs.core/IReduce}}, bit-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2495, :column 7, :end-line 2495, :end-column 14, :arglists (quote ([x n])), :doc "Set bit at index n"}, :name cljs.core/bit-set, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2495, :end-line 2495, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Set bit at index n"}, string-hash-cache-count {:name cljs.core/string-hash-cache-count, :file "cljs/core.cljs", :line 802, :column 1, :end-line 802, :end-column 29, :meta {:file "cljs/core.cljs", :line 802, :column 6, :end-line 802, :end-column 29}}, ->Eduction {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9047, :column 10, :end-line 9047, :end-column 18, :protocols #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :factory :positional, :arglists (quote ([xform coll]))}, :protocols #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/->Eduction, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([xform coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 9047, :end-line 9047, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform coll])), :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}}, tree-map-add {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7289, :column 8, :end-line 7289, :end-column 20, :private true, :arglists (quote ([comp tree k v found]))}, :private true, :name cljs.core/tree-map-add, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([comp tree k v found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7289, :end-line 7289, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp tree k v found]))}, ->ES6SetEntriesIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5581, :column 10, :end-line 5581, :end-column 31, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([s]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ES6SetEntriesIterator, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5581, :end-line 5581, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil}, -with-meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 532, :column 9, :end-line 532, :end-column 19, :tag clj, :protocol cljs.core/IWithMeta, :doc "Returns a new object with value of o and metadata meta added to it.", :arglists (quote ([o meta]))}, :protocol cljs.core/IWithMeta, :name cljs.core/-with-meta, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([o meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 530, :ret-tag clj, :end-line 532, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([o meta])), :doc "Returns a new object with value of o and metadata meta added to it."}, reset-cache {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9324, :column 8, :end-line 9324, :end-column 19, :private true, :arglists (quote ([method-cache method-table cached-hierarchy hierarchy]))}, :private true, :name cljs.core/reset-cache, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([method-cache method-table cached-hierarchy hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9324, :end-line 9324, :max-fixed-arity 4, :fn-var true, :arglists (quote ([method-cache method-table cached-hierarchy hierarchy]))}, ->PersistentArrayMapIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5735, :column 10, :end-line 5735, :end-column 36, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([arr i cnt]))}, :protocols #{cljs.core/Object}, :name cljs.core/->PersistentArrayMapIterator, :variadic false, :file "cljs/core.cljs", :end-column 36, :method-params ([arr i cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5735, :end-line 5735, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i cnt])), :skip-protocol-flag nil}, PersistentArrayMapIterator {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/PersistentArrayMapIterator, :file "cljs/core.cljs", :end-column 36, :type true, :column 10, :line 5735, :record false, :end-line 5735, :skip-protocol-flag nil}, butlast {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8082, :column 7, :end-line 8082, :end-column 14, :arglists (quote ([s])), :doc "Return a seq of all but the last item in coll, in linear time"}, :name cljs.core/butlast, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8082, :end-line 8082, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Return a seq of all but the last item in coll, in linear time"}, tail-off {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4563, :column 8, :end-line 4563, :end-column 16, :private true, :arglists (quote ([pv]))}, :private true, :name cljs.core/tail-off, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([pv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4563, :end-line 4563, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pv]))}, unchecked-subtract-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2394, :column 15, :end-line 2394, :end-column 37, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/unchecked-subtract-int, :variadic true, :file "cljs/core.cljs", :end-column 37, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2394, :ret-tag number, :end-line 2394, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result."}, -iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 713, :column 4, :end-line 713, :end-column 13, :protocol cljs.core/IIterable, :doc "Returns an iterator for coll.", :arglists (quote ([coll]))}, :protocol cljs.core/IIterable, :name cljs.core/-iterator, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 711, :end-line 713, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an iterator for coll."}, take-nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8332, :column 7, :end-line 8332, :end-column 15, :arglists (quote ([n] [n coll])), :doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/take-nth, :variadic false, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8332, :end-line 8332, :max-fixed-arity 2, :fn-var true, :arglists ([n] [n coll]), :doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided."}, first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1045, :column 7, :end-line 1045, :end-column 12, :arglists (quote ([coll])), :doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil."}, :name cljs.core/first, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1045, :end-line 1045, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil."}, native-satisfies? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 208, :column 16, :end-line 208, :end-column 33, :tag boolean, :arglists (quote ([p x])), :doc "Internal - do not use!"}, :name cljs.core/native-satisfies?, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([p x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 208, :ret-tag boolean, :end-line 208, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([p x])), :doc "Internal - do not use!"}, seq? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1947, :column 16, :end-line 1947, :end-column 20, :tag boolean, :arglists (quote ([s])), :doc "Return true if s satisfies ISeq"}, :name cljs.core/seq?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1947, :ret-tag boolean, :end-line 1947, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([s])), :doc "Return true if s satisfies ISeq"}, -global-hierarchy {:name cljs.core/-global-hierarchy, :file "cljs/core.cljs", :line 9214, :column 1, :end-line 9214, :end-column 33, :private true, :meta {:file "cljs/core.cljs", :line 9214, :column 16, :end-line 9214, :end-column 33, :private true}}, UUID {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/IComparable}, :name cljs.core/UUID, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 9616, :record false, :end-line 9616, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/IComparable}}, -sorted-seq-from {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 584, :column 9, :end-line 584, :end-column 25, :tag clj, :protocol cljs.core/ISorted, :doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)", :arglists (quote ([coll k ascending?]))}, :protocol cljs.core/ISorted, :name cljs.core/-sorted-seq-from, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([coll k ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 579, :ret-tag clj, :end-line 584, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll k ascending?])), :doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)"}, println-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8746, :column 7, :end-line 8746, :end-column 18, :arglists (quote ([& objs])), :doc "println to a string, returning it", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/println-str, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8746, :end-line 8746, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "println to a string, returning it"}, linear-traversal-nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1567, :column 8, :end-line 1567, :end-column 28, :private true, :arglists (quote ([coll n] [coll n not-found])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/linear-traversal-nth, :variadic false, :file "cljs/core.cljs", :end-column 28, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1567, :end-line 1567, :max-fixed-arity 3, :fn-var true, :arglists ([coll n] [coll n not-found])}, iterate {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4289, :column 7, :end-line 4289, :end-column 14, :arglists (quote ([f x])), :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :added "1.0"}, :added "1.0", :name cljs.core/iterate, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([f x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4289, :end-line 4289, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f x])), :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects"}, -empty {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 427, :column 4, :end-line 427, :end-column 10, :protocol cljs.core/IEmptyableCollection, :doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/count.", :arglists (quote ([coll]))}, :protocol cljs.core/IEmptyableCollection, :name cljs.core/-empty, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 425, :end-line 427, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/count."}, newline {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8702, :column 7, :end-line 8702, :end-column 14, :arglists (quote ([] [opts])), :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [opts]), :arglists ([] [opts]), :arglists-meta (nil nil)}}, :name cljs.core/newline, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [opts]), :arglists ([] [opts]), :arglists-meta (nil nil)}, :method-params ([] [opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8702, :end-line 8702, :max-fixed-arity 1, :fn-var true, :arglists ([] [opts])}, ILookup {:meta {:file "cljs/core.cljs", :line 469, :column 14, :end-line 469, :end-column 21, :doc "Protocol for looking up a value in a data structure.", :protocol-symbol true, :protocol-info {:methods {-lookup [[o k] [o k not-found]]}}}, :protocol-symbol true, :name cljs.core/ILookup, :file "cljs/core.cljs", :end-column 21, :column 1, :line 469, :protocol-info {:methods {-lookup [[o k] [o k not-found]]}}, :info nil, :end-line 469, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/BlackNode cljs.core/Subvec cljs.core/TransientHashMap cljs.core/TaggedLiteral cljs.core/PersistentVector cljs.core/TransientArrayMap cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/RedNode}, :doc "Protocol for looking up a value in a data structure."}, -chunked-rest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 677, :column 4, :end-line 677, :end-column 17, :protocol cljs.core/IChunkedSeq, :doc "Return a new collection of coll with the first chunk removed.", :arglists (quote ([coll]))}, :protocol cljs.core/IChunkedSeq, :name cljs.core/-chunked-rest, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 673, :end-line 677, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a new collection of coll with the first chunk removed."}, write-all {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8559, :column 7, :end-line 8559, :end-column 16, :arglists (quote ([writer & ss])), :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(writer ss)], :arglists ([writer & ss]), :arglists-meta (nil)}}, :name cljs.core/write-all, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(writer ss)], :arglists ([writer & ss]), :arglists-meta (nil)}, :method-params [(writer ss)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8559, :end-line 8559, :max-fixed-arity 1, :fn-var true, :arglists ([writer & ss])}, fn? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1732, :column 16, :end-line 1732, :end-column 19, :tag boolean, :arglists (quote ([f])), :doc "Return true if f is a JavaScript function or satisfies the Fn protocol."}, :name cljs.core/fn?, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1732, :ret-tag boolean, :end-line 1732, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :doc "Return true if f is a JavaScript function or satisfies the Fn protocol."}, -prefer-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9380, :column 4, :end-line 9380, :end-column 18, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf dispatch-val dispatch-val-y]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-prefer-method, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([mf dispatch-val dispatch-val-y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9376, :end-line 9380, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf dispatch-val dispatch-val-y])), :doc nil}, -assoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 480, :column 9, :end-line 480, :end-column 15, :tag clj, :protocol cljs.core/IAssociative, :doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it.", :arglists (quote ([coll k v]))}, :protocol cljs.core/IAssociative, :name cljs.core/-assoc, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 475, :ret-tag clj, :end-line 480, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll k v])), :doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it."}, doall {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8469, :column 7, :end-line 8469, :end-column 12, :arglists (quote ([coll] [n coll])), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [n coll]), :arglists ([coll] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/doall, :variadic false, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [n coll]), :arglists ([coll] [n coll]), :arglists-meta (nil nil)}, :method-params ([coll] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8469, :end-line 8469, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [n coll]), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time."}, keyword-identical? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2908, :column 16, :end-line 2908, :end-column 34, :tag boolean, :arglists (quote ([x y])), :doc "Efficient test to determine that two keywords are identical."}, :name cljs.core/keyword-identical?, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2908, :ret-tag boolean, :end-line 2908, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x y])), :doc "Efficient test to determine that two keywords are identical."}, pv-aset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4557, :column 8, :end-line 4557, :end-column 15, :private true, :arglists (quote ([node idx val]))}, :private true, :name cljs.core/pv-aset, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([node idx val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4557, :end-line 4557, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node idx val]))}, prefers {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9602, :column 7, :end-line 9602, :end-column 14, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of preferred value -> set of other values"}, :name cljs.core/prefers, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9602, :end-line 9602, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of preferred value -> set of other values"}, -js->clj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9118, :column 4, :end-line 9118, :end-column 12, :protocol cljs.core/IEncodeClojure, :doc "Transforms JavaScript values to Clojure", :arglists (quote ([x options]))}, :protocol cljs.core/IEncodeClojure, :name cljs.core/-js->clj, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x options]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9117, :end-line 9118, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x options])), :doc "Transforms JavaScript values to Clojure"}, LazySeq {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/LazySeq, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 2940, :record false, :end-line 2940, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, dedupe {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9020, :column 7, :end-line 9020, :end-column 13, :arglists (quote ([] [coll])), :doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}}, :name cljs.core/dedupe, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}, :method-params ([] [coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9020, :end-line 9020, :max-fixed-arity 1, :fn-var true, :arglists ([] [coll]), :doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided."}, unchecked-editable-array-for {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5141, :column 8, :end-line 5141, :end-column 36, :private true, :arglists (quote ([tv i]))}, :private true, :name cljs.core/unchecked-editable-array-for, :variadic false, :file "cljs/core.cljs", :end-column 36, :method-params ([tv i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5141, :end-line 5141, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tv i]))}, ->ES6Iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1097, :column 10, :end-line 1097, :end-column 21, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([s]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ES6Iterator, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1097, :end-line 1097, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil}, VectorNode {:num-fields 2, :protocols #{}, :name cljs.core/VectorNode, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 4549, :record false, :end-line 4549, :skip-protocol-flag nil}, dissoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1718, :column 7, :end-line 1718, :end-column 13, :arglists (quote ([coll] [coll k] [coll k & ks])), :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [coll k]), :arglists ([coll] [coll k] [coll k & ks]), :arglists-meta (nil nil nil)}}, :name cljs.core/dissoc, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [coll k]), :arglists ([coll] [coll k] [coll k & ks]), :arglists-meta (nil nil nil)}, :method-params ([coll] [coll k]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1718, :end-line 1718, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [coll k] [coll k & ks]), :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s)."}, atom {:name cljs.core/atom, :file "cljs/core.cljs", :line 6010, :column 1, :end-line 6010, :end-column 72, :declared true, :meta {:file "cljs/core.cljs", :line 6010, :column 68, :end-line 6010, :end-column 72, :declared true}}, bit-shift-right {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2509, :column 7, :end-line 2509, :end-column 22, :arglists (quote ([x n])), :doc "Bitwise shift right"}, :name cljs.core/bit-shift-right, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2509, :end-line 2509, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift right"}, *clojurescript-version* {:name cljs.core/*clojurescript-version*, :file "cljs/core.cljs", :line 16, :column 1, :end-line 16, :end-column 29, :meta {:file "cljs/core.cljs", :line 16, :column 6, :end-line 16, :end-column 29}}, -first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 453, :column 4, :end-line 453, :end-column 10, :protocol cljs.core/ISeq, :doc "Returns the first item in the collection coll. Used by cljs.core/first.", :arglists (quote ([coll]))}, :protocol cljs.core/ISeq, :name cljs.core/-first, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 451, :end-line 453, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the first item in the collection coll. Used by cljs.core/first."}, peek {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1806, :column 7, :end-line 1806, :end-column 11, :arglists (quote ([coll])), :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil."}, :name cljs.core/peek, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1806, :end-line 1806, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil."}, IKVReduce {:meta {:file "cljs/core.cljs", :line 543, :column 14, :end-line 543, :end-column 23, :doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv.", :protocol-symbol true, :protocol-info {:methods {-kv-reduce [[coll f init]]}}}, :protocol-symbol true, :name cljs.core/IKVReduce, :file "cljs/core.cljs", :end-column 23, :column 1, :line 543, :protocol-info {:methods {-kv-reduce [[coll f init]]}}, :info nil, :end-line 543, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap}, :doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv."}, aget {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 347, :column 7, :end-line 347, :end-column 11, :arglists (quote ([array i] [array i & idxs])), :doc "Returns the value at the index.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([array i]), :arglists ([array i] [array i & idxs]), :arglists-meta (nil nil)}}, :name cljs.core/aget, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([array i]), :arglists ([array i] [array i & idxs]), :arglists-meta (nil nil)}, :method-params ([array i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 347, :end-line 347, :max-fixed-arity 2, :fn-var true, :arglists ([array i] [array i & idxs]), :doc "Returns the value at the index."}, PersistentTreeMapSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/PersistentTreeMapSeq, :file "cljs/core.cljs", :end-column 30, :type true, :column 10, :line 6883, :record false, :end-line 6883, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -write {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 598, :column 4, :end-line 598, :end-column 10, :protocol cljs.core/IWriter, :doc "Writes s with writer and returns the result.", :arglists (quote ([writer s]))}, :protocol cljs.core/IWriter, :name cljs.core/-write, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([writer s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 596, :end-line 598, :max-fixed-arity 2, :fn-var true, :arglists (quote ([writer s])), :doc "Writes s with writer and returns the result."}, iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3509, :column 7, :end-line 3509, :end-column 11, :arglists (quote ([coll]))}, :name cljs.core/iter, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3509, :end-line 3509, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, mk-bound-fn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8186, :column 7, :end-line 8186, :end-column 18, :arglists (quote ([sc test key]))}, :name cljs.core/mk-bound-fn, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([sc test key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8186, :end-line 8186, :max-fixed-arity 3, :fn-var true, :arglists (quote ([sc test key]))}, last {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1507, :column 7, :end-line 1507, :end-column 11, :arglists (quote ([s])), :doc "Return the last item in coll, in linear time"}, :name cljs.core/last, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1507, :end-line 1507, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Return the last item in coll, in linear time"}, -default-dispatch-val {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9384, :column 4, :end-line 9384, :end-column 25, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-default-dispatch-val, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9376, :end-line 9384, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, pr {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8719, :column 7, :end-line 8719, :end-column 9, :arglists (quote ([& objs])), :doc "Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/pr, :variadic true, :file "cljs/core.cljs", :end-column 9, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8719, :end-line 8719, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader"}, tree-map-seq-push {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6876, :column 8, :end-line 6876, :end-column 25, :private true, :arglists (quote ([node stack ascending?]))}, :private true, :name cljs.core/tree-map-seq-push, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([node stack ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6876, :end-line 6876, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node stack ascending?]))}, namespace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2918, :column 7, :end-line 2918, :end-column 16, :arglists (quote ([x])), :doc "Returns the namespace String of a symbol or keyword, or nil if not present."}, :name cljs.core/namespace, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2918, :end-line 2918, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns the namespace String of a symbol or keyword, or nil if not present."}, empty-unordered-hash {:name cljs.core/empty-unordered-hash, :file "cljs/core.cljs", :line 1171, :column 1, :end-line 1171, :end-column 36, :private true, :meta {:file "cljs/core.cljs", :line 1171, :column 16, :end-line 1171, :end-column 36, :private true}}, obj-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7564, :column 7, :end-line 7564, :end-column 14, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new object map with supplied mappings.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name cljs.core/obj-map, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 7564, :end-line 7564, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new object map with supplied mappings."}, Reduced {:num-fields 1, :protocols #{cljs.core/IDeref}, :name cljs.core/Reduced, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 1220, :record false, :end-line 1220, :skip-protocol-flag #{cljs.core/IDeref}}, -conj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 433, :column 9, :end-line 433, :end-column 14, :tag clj, :protocol cljs.core/ICollection, :doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)", :arglists (quote ([coll o]))}, :protocol cljs.core/ICollection, :name cljs.core/-conj, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 431, :ret-tag clj, :end-line 433, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll o])), :doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)"}, NodeSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/NodeSeq, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 6504, :record false, :end-line 6504, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, = {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1078, :column 16, :end-line 1078, :end-column 17, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/=, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1078, :ret-tag boolean, :end-line 1078, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison."}, ITransientMap {:meta {:file "cljs/core.cljs", :line 645, :column 14, :end-line 645, :end-column 27, :doc "Protocol for adding mapping functionality to transient collections.", :protocol-symbol true, :protocol-info {:methods {-dissoc! [[tcoll key]]}}}, :protocol-symbol true, :name cljs.core/ITransientMap, :file "cljs/core.cljs", :end-column 27, :column 1, :line 645, :protocol-info {:methods {-dissoc! [[tcoll key]]}}, :info nil, :end-line 645, :impls #{cljs.core/TransientHashMap cljs.core/TransientArrayMap}, :doc "Protocol for adding mapping functionality to transient collections."}, push-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4579, :column 8, :end-line 4579, :end-column 17, :private true, :arglists (quote ([pv level parent tailnode]))}, :private true, :name cljs.core/push-tail, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pv level parent tailnode]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4579, :end-line 4579, :max-fixed-arity 4, :fn-var true, :arglists (quote ([pv level parent tailnode]))}, take {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4175, :column 7, :end-line 4175, :end-column 11, :arglists (quote ([n] [n coll])), :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/take, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4175, :end-line 4175, :max-fixed-arity 2, :fn-var true, :arglists ([n] [n coll]), :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided."}, vector? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1883, :column 16, :end-line 1883, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies IVector"}, :name cljs.core/vector?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1883, :ret-tag boolean, :end-line 1883, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IVector"}, array-index-of-equiv? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5633, :column 8, :end-line 5633, :end-column 29, :private true, :arglists (quote ([arr k]))}, :private true, :name cljs.core/array-index-of-equiv?, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5633, :end-line 5633, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, bitmap-indexed-node-index {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6036, :column 8, :end-line 6036, :end-column 33, :private true, :arglists (quote ([bitmap bit]))}, :private true, :name cljs.core/bitmap-indexed-node-index, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([bitmap bit]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6036, :end-line 6036, :max-fixed-arity 2, :fn-var true, :arglists (quote ([bitmap bit]))}, boolean {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1959, :column 16, :end-line 1959, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Coerce to boolean"}, :name cljs.core/boolean, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1959, :ret-tag boolean, :end-line 1959, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Coerce to boolean"}, IChunk {:meta {:file "cljs/core.cljs", :line 668, :column 14, :end-line 668, :end-column 20, :doc "Protocol for accessing the items of a chunk.", :protocol-symbol true, :protocol-info {:methods {-drop-first [[coll]]}}}, :protocol-symbol true, :name cljs.core/IChunk, :file "cljs/core.cljs", :end-column 20, :column 1, :line 668, :protocol-info {:methods {-drop-first [[coll]]}}, :info nil, :end-line 668, :impls #{cljs.core/ArrayChunk}, :doc "Protocol for accessing the items of a chunk."}, bit-shift-left {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2505, :column 7, :end-line 2505, :end-column 21, :arglists (quote ([x n])), :doc "Bitwise shift left"}, :name cljs.core/bit-shift-left, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2505, :end-line 2505, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift left"}, random-uuid {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9643, :column 7, :end-line 9643, :end-column 18, :arglists (quote ([]))}, :name cljs.core/random-uuid, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9643, :end-line 9643, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, rand-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9187, :column 7, :end-line 9187, :end-column 15, :arglists (quote ([n])), :doc "Returns a random integer between 0 (inclusive) and n (exclusive)."}, :name cljs.core/rand-int, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9187, :end-line 9187, :max-fixed-arity 1, :fn-var true, :arglists (quote ([n])), :doc "Returns a random integer between 0 (inclusive) and n (exclusive)."}, aclone {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 324, :column 7, :end-line 324, :end-column 13, :arglists (quote ([arr])), :doc "Returns a javascript array, cloned from the passed in array"}, :name cljs.core/aclone, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 324, :end-line 324, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr])), :doc "Returns a javascript array, cloned from the passed in array"}, BlackNode {:meta {:file "cljs/core.cljs", :line 6939, :column 18, :end-line 6939, :end-column 27, :declared true}, :num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/BlackNode, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 7042, :record false, :declared true, :end-line 7042, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, vreset! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4009, :column 7, :end-line 4009, :end-column 14, :arglists (quote ([vol newval])), :doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval."}, :name cljs.core/vreset!, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([vol newval]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4009, :end-line 4009, :max-fixed-arity 2, :fn-var true, :arglists (quote ([vol newval])), :doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval."}, chunk {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3129, :column 7, :end-line 3129, :end-column 12, :arglists (quote ([b]))}, :name cljs.core/chunk, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3129, :end-line 3129, :max-fixed-arity 1, :fn-var true, :arglists (quote ([b]))}, dec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2287, :column 7, :end-line 2287, :end-column 10, :arglists (quote ([x])), :doc "Returns a number one less than num."}, :name cljs.core/dec, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2287, :end-line 2287, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one less than num."}, map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4128, :column 7, :end-line 4128, :end-column 10, :arglists (quote ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f] [f coll] [f c1 c2] [f c1 c2 c3]), :arglists ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/map, :variadic true, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f] [f coll] [f c1 c2] [f c1 c2 c3]), :arglists ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :arglists-meta (nil nil nil nil nil)}, :method-params ([f] [f coll] [f c1 c2] [f c1 c2 c3]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 4128, :end-line 4128, :max-fixed-arity 4, :fn-var true, :arglists ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided."}, juxt {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8420, :column 7, :end-line 8420, :end-column 11, :arglists (quote ([f] [f g] [f g h] [f g h & fs])), :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([f] [f g] [f g h]), :arglists ([f] [f g] [f g h] [f g h & fs]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/juxt, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([f] [f g] [f g h]), :arglists ([f] [f g] [f g h] [f g h & fs]), :arglists-meta (nil nil nil nil)}, :method-params ([f] [f g] [f g h]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 8420, :end-line 8420, :max-fixed-arity 3, :fn-var true, :arglists ([f] [f g] [f g h] [f g h & fs]), :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]"}, < {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2239, :column 16, :end-line 2239, :end-column 17, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/<, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2239, :ret-tag boolean, :end-line 2239, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false."}, inode-kv-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6053, :column 8, :end-line 6053, :end-column 23, :private true, :arglists (quote ([arr f init]))}, :private true, :name cljs.core/inode-kv-reduce, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([arr f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6053, :end-line 6053, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr f init]))}, obj-map->hash-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5433, :column 8, :end-line 5433, :end-column 25, :private true, :arglists (quote ([m k v]))}, :private true, :name cljs.core/obj-map->hash-map, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([m k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5433, :end-line 5433, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m k v]))}, test {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9743, :column 7, :end-line 9743, :end-column 11, :arglists (quote ([v])), :doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception"}, :name cljs.core/test, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9743, :end-line 9743, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception"}, rest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1056, :column 12, :end-line 1056, :end-column 16, :tag seq, :arglists (quote ([coll])), :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument."}, :name cljs.core/rest, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1056, :ret-tag seq, :end-line 1056, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument."}, ex-data {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9706, :column 7, :end-line 9706, :end-column 14, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns exception data (a map) if ex is an ExceptionInfo.\n  Otherwise returns nil."}, :name cljs.core/ex-data, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9706, :end-line 9706, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns exception data (a map) if ex is an ExceptionInfo.\n  Otherwise returns nil."}, PersistentArrayMapSeq {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/PersistentArrayMapSeq, :file "cljs/core.cljs", :end-column 31, :type true, :column 10, :line 5674, :record false, :end-line 5674, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -drop-first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 670, :column 4, :end-line 670, :end-column 15, :protocol cljs.core/IChunk, :doc "Return a new chunk of coll with the first item removed.", :arglists (quote ([coll]))}, :protocol cljs.core/IChunk, :name cljs.core/-drop-first, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 668, :end-line 670, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a new chunk of coll with the first item removed."}, isa? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9224, :column 16, :end-line 9224, :end-column 20, :tag boolean, :arglists (quote ([child parent] [h child parent])), :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([child parent] [h child parent]), :arglists ([child parent] [h child parent]), :arglists-meta (nil nil)}}, :name cljs.core/isa?, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([child parent] [h child parent]), :arglists ([child parent] [h child parent]), :arglists-meta (nil nil)}, :method-params ([child parent] [h child parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9224, :ret-tag boolean, :end-line 9224, :max-fixed-arity 3, :tag boolean, :fn-var true, :arglists ([child parent] [h child parent]), :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy"}, -clone {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 417, :column 9, :end-line 417, :end-column 15, :tag clj, :protocol cljs.core/ICloneable, :doc "Creates a clone of value.", :arglists (quote ([value]))}, :protocol cljs.core/ICloneable, :name cljs.core/-clone, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 415, :ret-tag clj, :end-line 417, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([value])), :doc "Creates a clone of value."}, munge {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9845, :column 7, :end-line 9845, :end-column 12, :arglists (quote ([name]))}, :name cljs.core/munge, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9845, :end-line 9845, :max-fixed-arity 1, :fn-var true, :arglists (quote ([name]))}, empty-ordered-hash {:name cljs.core/empty-ordered-hash, :file "cljs/core.cljs", :line 1156, :column 1, :end-line 1156, :end-column 34, :private true, :meta {:file "cljs/core.cljs", :line 1156, :column 16, :end-line 1156, :end-column 34, :private true}}, DEMUNGE_MAP {:name cljs.core/DEMUNGE_MAP, :file "cljs/core.cljs", :line 285, :column 1, :end-line 286, :end-column 14, :jsdoc ["@enum {string}"], :meta {:file "cljs/core.cljs", :line 286, :column 3, :end-line 286, :end-column 14, :jsdoc ["@enum {string}"]}}, ES6IteratorSeq {:num-fields 3, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :name cljs.core/ES6IteratorSeq, :file "cljs/core.cljs", :end-column 24, :type true, :column 10, :line 1113, :record false, :end-line 1113, :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}}, ->NeverEquiv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5388, :column 10, :end-line 5388, :end-column 20, :protocols #{cljs.core/IEquiv cljs.core/Object}, :skip-protocol-flag #{cljs.core/IEquiv}, :factory :positional, :arglists (quote ([]))}, :protocols #{cljs.core/IEquiv cljs.core/Object}, :name cljs.core/->NeverEquiv, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5388, :end-line 5388, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :skip-protocol-flag #{cljs.core/IEquiv}}, re-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8516, :column 7, :end-line 8516, :end-column 13, :arglists (quote ([re s])), :doc "Returns a lazy sequence of successive matches of re in s."}, :name cljs.core/re-seq, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8516, :end-line 8516, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns a lazy sequence of successive matches of re in s."}, char? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 202, :column 16, :end-line 202, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript char."}, :name cljs.core/char?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 202, :ret-tag boolean, :end-line 202, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript char."}, make-hierarchy {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9210, :column 7, :end-line 9210, :end-column 21, :arglists (quote ([])), :doc "Creates a hierarchy object for use with derive, isa? etc."}, :name cljs.core/make-hierarchy, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9210, :end-line 9210, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Creates a hierarchy object for use with derive, isa? etc."}, Symbol {:meta {:file "cljs/core.cljs", :line 798, :column 15, :end-line 798, :end-column 21, :declared true}, :num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :name cljs.core/Symbol, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 894, :record false, :declared true, :end-line 894, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}}, tv-push-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5115, :column 8, :end-line 5115, :end-column 20, :private true, :arglists (quote ([tv level parent tail-node]))}, :private true, :name cljs.core/tv-push-tail, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([tv level parent tail-node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5115, :end-line 5115, :max-fixed-arity 4, :fn-var true, :arglists (quote ([tv level parent tail-node]))}, -reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 538, :column 4, :end-line 538, :end-column 11, :protocol cljs.core/IReduce, :doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc.", :arglists (quote ([coll f] [coll f start])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll f] [coll f start]), :arglists ([coll f] [coll f start]), :arglists-meta (nil nil)}}, :protocol cljs.core/IReduce, :name cljs.core/-reduce, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll f] [coll f start]), :arglists ([coll f] [coll f start]), :arglists-meta (nil nil)}, :method-params ([coll f] [coll f start]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 535, :end-line 538, :max-fixed-arity 3, :fn-var true, :arglists ([coll f] [coll f start]), :doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc."}, -count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 422, :column 12, :end-line 422, :end-column 18, :tag number, :protocol cljs.core/ICounted, :doc "Calculates the count of coll in constant time. Used by cljs.core/count.", :arglists (quote ([coll]))}, :protocol cljs.core/ICounted, :name cljs.core/-count, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 420, :ret-tag number, :end-line 422, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Calculates the count of coll in constant time. Used by cljs.core/count."}, keep {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3849, :column 7, :end-line 3849, :end-column 11, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name cljs.core/keep, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3849, :end-line 3849, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided."}, char {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2307, :column 7, :end-line 2307, :end-column 11, :arglists (quote ([x])), :doc "Coerce to char"}, :name cljs.core/char, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2307, :end-line 2307, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to char"}, mapcat {:protocol-inline nil, :meta {:added "1.0", :file "cljs/core.cljs", :end-column 13, :static true, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([f]), :arglists ([f] [f & colls]), :arglists-meta (nil nil)}, :column 7, :line 4343, :end-line 4343, :arglists (quote ([f] [f & colls])), :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided"}, :added "1.0", :name cljs.core/mapcat, :variadic true, :file "cljs/core.cljs", :end-column 13, :static true, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([f]), :arglists ([f] [f & colls]), :arglists-meta (nil nil)}, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4343, :end-line 4343, :max-fixed-arity 1, :fn-var true, :arglists ([f] [f & colls]), :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided"}, unchecked-long {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2421, :column 7, :end-line 2421, :end-column 21, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, :name cljs.core/unchecked-long, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2421, :end-line 2421, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, m3-seed {:name cljs.core/m3-seed, :file "cljs/core.cljs", :line 756, :column 1, :end-line 756, :end-column 13, :meta {:file "cljs/core.cljs", :line 756, :column 6, :end-line 756, :end-column 13}}, some? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 186, :column 16, :end-line 186, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is not nil, false otherwise."}, :name cljs.core/some?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 186, :ret-tag boolean, :end-line 186, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is not nil, false otherwise."}, unchecked-negate {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2376, :column 7, :end-line 2376, :end-column 23, :arglists (quote ([x]))}, :name cljs.core/unchecked-negate, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2376, :end-line 2376, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, reverse {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2774, :column 7, :end-line 2774, :end-column 14, :arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reverse order. Not lazy."}, :name cljs.core/reverse, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2774, :end-line 2774, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reverse order. Not lazy."}, range {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8323, :column 7, :end-line 8323, :end-column 12, :arglists (quote ([] [end] [start end] [start end step])), :doc "Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([] [end] [start end] [start end step]), :arglists ([] [end] [start end] [start end step]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/range, :variadic false, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([] [end] [start end] [start end step]), :arglists ([] [end] [start end] [start end step]), :arglists-meta (nil nil nil nil)}, :method-params ([] [end] [start end] [start end step]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 8323, :end-line 8323, :max-fixed-arity 3, :fn-var true, :arglists ([] [end] [start end] [start end step]), :doc "Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity."}, bit-count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2521, :column 7, :end-line 2521, :end-column 16, :arglists (quote ([v])), :doc "Counts the number of bits set in n"}, :name cljs.core/bit-count, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2521, :end-line 2521, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "Counts the number of bits set in n"}, create-node {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6486, :column 8, :end-line 6486, :end-column 19, :private true, :arglists (quote ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2])), :top-fn {:variadic false, :max-fixed-arity 7, :method-params ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :arglists ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/create-node, :variadic false, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 7, :method-params ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :arglists ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :arglists-meta (nil nil)}, :method-params ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6486, :end-line 6486, :max-fixed-arity 7, :fn-var true, :arglists ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2])}, sort {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2072, :column 7, :end-line 2072, :end-column 11, :arglists (quote ([coll] [comp coll])), :doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [comp coll]), :arglists ([coll] [comp coll]), :arglists-meta (nil nil)}}, :name cljs.core/sort, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [comp coll]), :arglists ([coll] [comp coll]), :arglists-meta (nil nil)}, :method-params ([coll] [comp coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2072, :end-line 2072, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [comp coll]), :doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare."}, ->MetaFn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1737, :column 10, :end-line 1737, :end-column 16, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([afn meta]))}, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :name cljs.core/->MetaFn, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([afn meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1737, :end-line 1737, :max-fixed-arity 2, :fn-var true, :arglists (quote ([afn meta])), :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}}, unchecked-inc-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2359, :column 7, :end-line 2359, :end-column 24, :arglists (quote ([x]))}, :name cljs.core/unchecked-inc-int, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2359, :end-line 2359, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, -compare {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 664, :column 12, :end-line 664, :end-column 20, :tag number, :protocol cljs.core/IComparable, :doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y.", :arglists (quote ([x y]))}, :protocol cljs.core/IComparable, :name cljs.core/-compare, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 662, :ret-tag number, :end-line 664, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x y])), :doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y."}, map-indexed {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3822, :column 7, :end-line 3822, :end-column 18, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name cljs.core/map-indexed, :variadic false, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3822, :end-line 3822, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item."}, array-list {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8133, :column 7, :end-line 8133, :end-column 17, :arglists (quote ([]))}, :name cljs.core/array-list, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8133, :end-line 8133, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, rand-nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9191, :column 7, :end-line 9191, :end-column 15, :arglists (quote ([coll])), :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection."}, :name cljs.core/rand-nth, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9191, :end-line 9191, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection."}, comp {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3739, :column 7, :end-line 3739, :end-column 11, :arglists (quote ([] [f] [f g] [f g h] [f1 f2 f3 & fs])), :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([] [f] [f g] [f g h]), :arglists ([] [f] [f g] [f g h] [f1 f2 f3 & fs]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/comp, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([] [f] [f g] [f g h]), :arglists ([] [f] [f g] [f g h] [f1 f2 f3 & fs]), :arglists-meta (nil nil nil nil nil)}, :method-params ([] [f] [f g] [f g h]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 3739, :end-line 3739, :max-fixed-arity 3, :fn-var true, :arglists ([] [f] [f g] [f g h] [f1 f2 f3 & fs]), :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc."}, array-chunk {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3049, :column 7, :end-line 3049, :end-column 18, :arglists (quote ([arr] [arr off] [arr off end])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([arr] [arr off] [arr off end]), :arglists ([arr] [arr off] [arr off end]), :arglists-meta (nil nil nil)}}, :name cljs.core/array-chunk, :variadic false, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([arr] [arr off] [arr off end]), :arglists ([arr] [arr off] [arr off end]), :arglists-meta (nil nil nil)}, :method-params ([arr] [arr off] [arr off end]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 3049, :end-line 3049, :max-fixed-arity 3, :fn-var true, :arglists ([arr] [arr off] [arr off end])}, dispatch-fn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9610, :column 7, :end-line 9610, :end-column 18, :arglists (quote ([multifn])), :doc "Given a multimethod, return it's dispatch-fn."}, :name cljs.core/dispatch-fn, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9610, :end-line 9610, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, return it's dispatch-fn."}, bit-shift-right-zero-fill {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2513, :column 7, :end-line 2513, :end-column 32, :arglists (quote ([x n])), :doc "DEPRECATED: Bitwise shift right with zero fill"}, :name cljs.core/bit-shift-right-zero-fill, :variadic false, :file "cljs/core.cljs", :end-column 32, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2513, :end-line 2513, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "DEPRECATED: Bitwise shift right with zero fill"}, t5609 {:num-fields 2, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t5609, :file "cljs/core.cljs", :type true, :anonymous true, :column 3, :line 3455, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, js-reserved? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9812, :column 8, :end-line 9812, :end-column 20, :private true, :arglists (quote ([x]))}, :private true, :name cljs.core/js-reserved?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9812, :end-line 9812, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, ->t5609 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([nil-iter meta5610])), :file "cljs/core.cljs"}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t5609, :variadic false, :file "cljs/core.cljs", :method-params ([nil-iter meta5610]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :line 3455, :max-fixed-arity 2, :fn-var true, :arglists (quote ([nil-iter meta5610])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, -as-transient {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 629, :column 9, :end-line 629, :end-column 22, :tag clj, :protocol cljs.core/IEditableCollection, :doc "Returns a new, transient version of the collection, in constant time.", :arglists (quote ([coll]))}, :protocol cljs.core/IEditableCollection, :name cljs.core/-as-transient, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 627, :ret-tag clj, :end-line 629, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time."}, dorun {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8456, :column 7, :end-line 8456, :end-column 12, :arglists (quote ([coll] [n coll])), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [n coll]), :arglists ([coll] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/dorun, :variadic false, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [n coll]), :arglists ([coll] [n coll]), :arglists-meta (nil nil)}, :method-params ([coll] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8456, :end-line 8456, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [n coll]), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil."}, pr-sequential-writer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8536, :column 7, :end-line 8536, :end-column 27, :arglists (quote ([writer print-one begin sep end opts coll]))}, :name cljs.core/pr-sequential-writer, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([writer print-one begin sep end opts coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8536, :end-line 8536, :max-fixed-arity 7, :fn-var true, :arglists (quote ([writer print-one begin sep end opts coll]))}, accumulating-seq-count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1540, :column 8, :end-line 1540, :end-column 30, :private true, :arglists (quote ([coll]))}, :private true, :name cljs.core/accumulating-seq-count, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1540, :end-line 1540, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, IIndexed {:meta {:file "cljs/core.cljs", :line 442, :column 14, :end-line 442, :end-column 22, :doc "Protocol for collections to provide idexed-based access to their items.", :protocol-symbol true, :protocol-info {:methods {-nth [[coll n] [coll n not-found]]}}}, :protocol-symbol true, :name cljs.core/IIndexed, :file "cljs/core.cljs", :end-column 22, :column 1, :line 442, :protocol-info {:methods {-nth [[coll n] [coll n not-found]]}}, :info nil, :end-line 442, :impls #{cljs.core/TransientVector cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/ArrayChunk cljs.core/Range cljs.core/RedNode}, :doc "Protocol for collections to provide idexed-based access to their items."}, disj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1821, :column 7, :end-line 1821, :end-column 11, :arglists (quote ([coll] [coll k] [coll k & ks])), :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [coll k]), :arglists ([coll] [coll k] [coll k & ks]), :arglists-meta (nil nil nil)}}, :name cljs.core/disj, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [coll k]), :arglists ([coll] [coll k] [coll k & ks]), :arglists-meta (nil nil nil)}, :method-params ([coll] [coll k]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1821, :end-line 1821, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [coll k] [coll k & ks]), :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s)."}, IPrintWithWriter {:meta {:file "cljs/core.cljs", :line 603, :column 14, :end-line 603, :end-column 30, :doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append.", :protocol-symbol true, :protocol-info {:methods {-pr-writer [[o writer opts]]}}}, :protocol-symbol true, :name cljs.core/IPrintWithWriter, :file "cljs/core.cljs", :end-column 30, :column 1, :line 603, :protocol-info {:methods {-pr-writer [[o writer opts]]}}, :info nil, :end-line 603, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Volatile cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ExceptionInfo cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/TaggedLiteral cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/LazyTransformer cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append."}, ->UUID {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9616, :column 10, :end-line 9616, :end-column 14, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/IComparable}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/IComparable}, :factory :positional, :arglists (quote ([uuid __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/IComparable}, :name cljs.core/->UUID, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([uuid __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 9616, :end-line 9616, :max-fixed-arity 2, :fn-var true, :arglists (quote ([uuid __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/IComparable}}, IVector {:meta {:file "cljs/core.cljs", :line 512, :column 14, :end-line 512, :end-column 21, :doc "Protocol for adding vector functionality to collections.", :protocol-symbol true, :protocol-info {:methods {-assoc-n [[coll n val]]}}}, :protocol-symbol true, :name cljs.core/IVector, :file "cljs/core.cljs", :end-column 21, :column 1, :line 512, :protocol-info {:methods {-assoc-n [[coll n val]]}}, :info nil, :end-line 512, :impls #{cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/RedNode}, :doc "Protocol for adding vector functionality to collections."}, IIterable {:meta {:file "cljs/core.cljs", :line 711, :column 14, :end-line 711, :end-column 23, :doc "Protocol for iterating over a collection.", :protocol-symbol true, :protocol-info {:methods {-iterator [[coll]]}}}, :protocol-symbol true, :name cljs.core/IIterable, :file "cljs/core.cljs", :end-column 23, :column 1, :line 711, :protocol-info {:methods {-iterator [[coll]]}}, :info nil, :end-line 711, :impls #{cljs.core/PersistentArrayMap cljs.core/IndexedSeq cljs.core/PersistentVector cljs.core/Range}, :doc "Protocol for iterating over a collection."}, *2 {:name cljs.core/*2, :file "cljs/core.cljs", :line 139, :column 1, :end-line 141, :end-column 5, :doc "bound in a repl thread to the second most recent value printed", :meta {:file "cljs/core.cljs", :line 141, :column 3, :end-line 141, :end-column 5, :doc "bound in a repl thread to the second most recent value printed"}}, Eduction {:num-fields 2, :protocols #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/Eduction, :file "cljs/core.cljs", :end-column 18, :type true, :column 10, :line 9047, :record false, :end-line 9047, :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}}, pv-clone-node {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4560, :column 8, :end-line 4560, :end-column 21, :private true, :arglists (quote ([node]))}, :private true, :name cljs.core/pv-clone-node, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4560, :end-line 4560, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, cons {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2847, :column 7, :end-line 2847, :end-column 11, :arglists (quote ([x coll])), :doc "Returns a new seq where x is the first element and seq is the rest."}, :name cljs.core/cons, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2847, :end-line 2847, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x coll])), :doc "Returns a new seq where x is the first element and seq is the rest."}, PersistentTreeSet {:num-fields 3, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/PersistentTreeSet, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7906, :record false, :end-line 7906, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, floats {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2431, :column 7, :end-line 2431, :end-column 13, :arglists (quote ([x]))}, :name cljs.core/floats, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2431, :end-line 2431, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, TransientVector {:meta {:file "cljs/core.cljs", :line 4665, :column 44, :end-line 4665, :end-column 59, :declared true}, :num-fields 4, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientVector, :file "cljs/core.cljs", :end-column 25, :type true, :column 10, :line 5157, :record false, :declared true, :end-line 5157, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}}, pos? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2541, :column 16, :end-line 2541, :end-column 20, :tag boolean, :arglists (quote ([n])), :doc "Returns true if num is greater than zero, else false"}, :name cljs.core/pos?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2541, :ret-tag boolean, :end-line 2541, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if num is greater than zero, else false"}, fnil {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3797, :column 7, :end-line 3797, :end-column 11, :arglists (quote ([f x] [f x y] [f x y z])), :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([f x] [f x y] [f x y z]), :arglists ([f x] [f x y] [f x y z]), :arglists-meta (nil nil nil)}}, :name cljs.core/fnil, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([f x] [f x y] [f x y z]), :arglists ([f x] [f x y] [f x y z]), :arglists-meta (nil nil nil)}, :method-params ([f x] [f x y] [f x y z]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 3797, :end-line 3797, :max-fixed-arity 4, :fn-var true, :arglists ([f x] [f x y] [f x y z]), :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched."}, merge-with {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7740, :column 7, :end-line 7740, :end-column 17, :arglists (quote ([f & maps])), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f maps)], :arglists ([f & maps]), :arglists-meta (nil)}}, :name cljs.core/merge-with, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f maps)], :arglists ([f & maps]), :arglists-meta (nil)}, :method-params [(f maps)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 7740, :end-line 7740, :max-fixed-arity 1, :fn-var true, :arglists ([f & maps]), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter)."}, nthrest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1651, :column 7, :end-line 1651, :end-column 14, :arglists (quote ([coll n])), :doc "Returns the nth rest of coll, coll when n is 0."}, :name cljs.core/nthrest, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1651, :end-line 1651, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll n])), :doc "Returns the nth rest of coll, coll when n is 0."}, sequential? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1859, :column 16, :end-line 1859, :end-column 27, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISequential"}, :name cljs.core/sequential?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1859, :ret-tag boolean, :end-line 1859, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISequential"}, tree-map-replace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7387, :column 8, :end-line 7387, :end-column 24, :private true, :arglists (quote ([comp tree k v]))}, :private true, :name cljs.core/tree-map-replace, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([comp tree k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7387, :end-line 7387, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp tree k v]))}, m3-mix-H1 {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 763, :column 15, :end-line 763, :end-column 24, :tag number, :arglists (quote ([h1 k1]))}, :name cljs.core/m3-mix-H1, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([h1 k1]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 763, :ret-tag number, :end-line 763, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([h1 k1]))}, ->TransientArrayMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5929, :column 10, :end-line 5929, :end-column 27, :protocols #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :factory :positional, :arglists (quote ([editable? len arr]))}, :protocols #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientArrayMap, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([editable? len arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5929, :end-line 5929, :max-fixed-arity 3, :fn-var true, :arglists (quote ([editable? len arr])), :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, prim-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1410, :column 7, :end-line 1410, :end-column 15, :arglists (quote ([prim] [prim i])), :doc "Create seq from a primitive JavaScript Array-like.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([prim] [prim i]), :arglists ([prim] [prim i]), :arglists-meta (nil nil)}}, :name cljs.core/prim-seq, :variadic false, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([prim] [prim i]), :arglists ([prim] [prim i]), :arglists-meta (nil nil)}, :method-params ([prim] [prim i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1410, :end-line 1410, :max-fixed-arity 2, :fn-var true, :arglists ([prim] [prim i]), :doc "Create seq from a primitive JavaScript Array-like."}, *print-level* {:name cljs.core/*print-level*, :file "cljs/core.cljs", :line 104, :column 1, :end-line 114, :end-column 16, :dynamic true, :doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.", :meta {:file "cljs/core.cljs", :line 114, :column 3, :end-line 114, :end-column 16, :dynamic true, :doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit."}}, shuffle {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2113, :column 7, :end-line 2113, :end-column 14, :arglists (quote ([coll])), :doc "Return a random permutation of coll"}, :name cljs.core/shuffle, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2113, :end-line 2113, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a random permutation of coll"}, ChunkedSeq {:meta {:file "cljs/core.cljs", :line 1887, :column 22, :end-line 1887, :end-column 32, :declared true}, :num-fields 6, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ChunkedSeq, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 4890, :record false, :declared true, :end-line 4890, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, hash-keyword {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2860, :column 7, :end-line 2860, :end-column 19, :arglists (quote ([k]))}, :name cljs.core/hash-keyword, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2860, :end-line 2860, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, find {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1988, :column 7, :end-line 1988, :end-column 11, :arglists (quote ([coll k])), :doc "Returns the map entry for key, or nil if key not present."}, :name cljs.core/find, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1988, :end-line 1988, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll k])), :doc "Returns the map entry for key, or nil if key not present."}, alength {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 361, :column 15, :end-line 361, :end-column 22, :tag number, :arglists (quote ([array])), :doc "Returns the length of the array. Works on arrays of all types."}, :name cljs.core/alength, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([array]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 361, :ret-tag number, :end-line 361, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([array])), :doc "Returns the length of the array. Works on arrays of all types."}, bit-xor {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2457, :column 7, :end-line 2457, :end-column 14, :arglists (quote ([x y] [x y & more])), :doc "Bitwise exclusive or", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}}, :name cljs.core/bit-xor, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2457, :end-line 2457, :max-fixed-arity 2, :fn-var true, :arglists ([x y] [x y & more]), :doc "Bitwise exclusive or"}, ->IndexedSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1337, :column 10, :end-line 1337, :end-column 20, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/ISequential cljs.core/IReduce}, :factory :positional, :arglists (quote ([arr i]))}, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/->IndexedSeq, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1337, :end-line 1337, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/ISequential cljs.core/IReduce}}, ObjMap {:num-fields 5, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/ObjMap, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 5457, :record false, :end-line 5457, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, unsigned-bit-shift-right {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2517, :column 7, :end-line 2517, :end-column 31, :arglists (quote ([x n])), :doc "Bitwise shift right with zero fill"}, :name cljs.core/unsigned-bit-shift-right, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2517, :end-line 2517, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift right with zero fill"}, ES6SetEntriesIterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6SetEntriesIterator, :file "cljs/core.cljs", :end-column 31, :type true, :column 10, :line 5581, :record false, :end-line 5581, :skip-protocol-flag nil}, neg? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2550, :column 16, :end-line 2550, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Returns true if num is less than zero, else false"}, :name cljs.core/neg?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2550, :ret-tag boolean, :end-line 2550, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if num is less than zero, else false"}, Cons {:num-fields 4, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/Cons, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 2798, :record false, :end-line 2798, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -remove-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9379, :column 4, :end-line 9379, :end-column 18, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf dispatch-val]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-remove-method, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([mf dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9376, :end-line 9379, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf dispatch-val])), :doc nil}, ->StringIter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3461, :column 10, :end-line 3461, :end-column 20, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([s i]))}, :protocols #{cljs.core/Object}, :name cljs.core/->StringIter, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([s i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3461, :end-line 3461, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s i])), :skip-protocol-flag nil}, js-invoke {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 376, :column 7, :end-line 376, :end-column 16, :arglists (quote ([obj s & args])), :doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(obj s args)], :arglists ([obj s & args]), :arglists-meta (nil)}}, :name cljs.core/js-invoke, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(obj s args)], :arglists ([obj s & args]), :arglists-meta (nil)}, :method-params [(obj s args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 376, :end-line 376, :max-fixed-arity 2, :fn-var true, :arglists ([obj s & args]), :doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name."}, ->List {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2646, :column 10, :end-line 2646, :end-column 14, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta first rest count __hash]))}, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->List, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([meta first rest count __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 2646, :end-line 2646, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta first rest count __hash])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, m3-mix-K1 {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 760, :column 15, :end-line 760, :end-column 24, :tag number, :arglists (quote ([k1]))}, :name cljs.core/m3-mix-K1, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([k1]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 760, :ret-tag number, :end-line 760, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([k1]))}, unchecked-float {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2322, :column 15, :end-line 2322, :end-column 30, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-float, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2322, :ret-tag number, :end-line 2322, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, undefined? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1942, :column 16, :end-line 1942, :end-column 26, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x identical to the JavaScript undefined value."}, :name cljs.core/undefined?, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1942, :ret-tag boolean, :end-line 1942, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x identical to the JavaScript undefined value."}, IMeta {:meta {:file "cljs/core.cljs", :line 525, :column 14, :end-line 525, :end-column 19, :doc "Protocol for accessing the metadata of an object.", :protocol-symbol true, :protocol-info {:methods {-meta [[o]]}}}, :protocol-symbol true, :name cljs.core/IMeta, :file "cljs/core.cljs", :end-column 19, :column 1, :line 525, :protocol-info {:methods {-meta [[o]]}}, :info nil, :end-line 525, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/t8242 cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet function cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/MetaFn cljs.core/Range cljs.core/t8245 cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for accessing the metadata of an object."}, reduced? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1229, :column 16, :end-line 1229, :end-column 24, :tag boolean, :arglists (quote ([r])), :doc "Returns true if x is the result of a call to reduced"}, :name cljs.core/reduced?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([r]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1229, :ret-tag boolean, :end-line 1229, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([r])), :doc "Returns true if x is the result of a call to reduced"}, apply-to {:protocol-inline nil, :meta {:arglists (quote ([f argc args])), :file "cljs/core.cljs"}, :name cljs.core/apply-to, :variadic false, :file "cljs/core.cljs", :method-params ([f argc args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3376, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f argc args]))}, disj! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3361, :column 7, :end-line 3361, :end-column 12, :arglists (quote ([tcoll val] [tcoll val & vals])), :doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([tcoll val]), :arglists ([tcoll val] [tcoll val & vals]), :arglists-meta (nil nil)}}, :name cljs.core/disj!, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([tcoll val]), :arglists ([tcoll val] [tcoll val & vals]), :arglists-meta (nil nil)}, :method-params ([tcoll val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3361, :end-line 3361, :max-fixed-arity 2, :fn-var true, :arglists ([tcoll val] [tcoll val & vals]), :doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s)."}, -lookup {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 471, :column 4, :end-line 471, :end-column 11, :protocol cljs.core/ILookup, :doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned.", :arglists (quote ([o k] [o k not-found])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([o k] [o k not-found]), :arglists ([o k] [o k not-found]), :arglists-meta (nil nil)}}, :protocol cljs.core/ILookup, :name cljs.core/-lookup, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([o k] [o k not-found]), :arglists ([o k] [o k not-found]), :arglists-meta (nil nil)}, :method-params ([o k] [o k not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 469, :end-line 471, :max-fixed-arity 3, :fn-var true, :arglists ([o k] [o k not-found]), :doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned."}, ICloneable {:meta {:file "cljs/core.cljs", :line 415, :column 14, :end-line 415, :end-column 24, :doc "Protocol for cloning a value.", :protocol-symbol true, :protocol-info {:methods {-clone [[value]]}}}, :protocol-symbol true, :name cljs.core/ICloneable, :file "cljs/core.cljs", :end-column 24, :column 1, :line 415, :protocol-info {:methods {-clone [[value]]}}, :info nil, :end-line 415, :impls #{cljs.core/PersistentHashMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/Subvec cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/Range}, :doc "Protocol for cloning a value."}, IEncodeClojure {:meta {:file "cljs/core.cljs", :line 9117, :column 14, :end-line 9117, :end-column 28, :doc nil, :protocol-symbol true, :protocol-info {:methods {-js->clj [[x options]]}}}, :protocol-symbol true, :name cljs.core/IEncodeClojure, :file "cljs/core.cljs", :end-column 28, :column 1, :line 9117, :protocol-info {:methods {-js->clj [[x options]]}}, :info nil, :end-line 9117, :impls #{}, :doc nil}, booleans {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2426, :column 7, :end-line 2426, :end-column 15, :arglists (quote ([x]))}, :name cljs.core/booleans, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2426, :end-line 2426, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, ->ArrayList {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8125, :column 10, :end-line 8125, :end-column 19, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([arr]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayList, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 8125, :end-line 8125, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr])), :skip-protocol-flag nil}, RSeq {:meta {:file "cljs/core.cljs", :line 1318, :column 25, :end-line 1318, :end-column 29, :declared true}, :num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/RSeq, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 1427, :record false, :declared true, :end-line 1427, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, mask {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6018, :column 8, :end-line 6018, :end-column 12, :private true, :arglists (quote ([hash shift]))}, :private true, :name cljs.core/mask, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([hash shift]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6018, :end-line 6018, :max-fixed-arity 2, :fn-var true, :arglists (quote ([hash shift]))}, int-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3166, :column 7, :end-line 3166, :end-column 16, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}}, :name cljs.core/int-array, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3166, :end-line 3166, :max-fixed-arity 2, :fn-var true, :arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure."}, find-and-cache-best-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9351, :column 8, :end-line 9351, :end-column 34, :private true, :arglists (quote ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]))}, :private true, :name cljs.core/find-and-cache-best-method, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9351, :end-line 9351, :max-fixed-arity 7, :fn-var true, :arglists (quote ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]))}, set? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1848, :column 16, :end-line 1848, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x satisfies ISet"}, :name cljs.core/set?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1848, :ret-tag boolean, :end-line 1848, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x satisfies ISet"}, iterable? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1007, :column 7, :end-line 1007, :end-column 16, :arglists (quote ([x])), :doc "Return true if x implements IIterable protocol."}, :name cljs.core/iterable?, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1007, :end-line 1007, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x implements IIterable protocol."}, cat {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9008, :column 7, :end-line 9008, :end-column 10, :arglists (quote ([rf])), :doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.", :added "1.7"}, :added "1.7", :name cljs.core/cat, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([rf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9008, :end-line 9008, :max-fixed-arity 1, :fn-var true, :arglists (quote ([rf])), :doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction."}, ->ES6EntriesIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5568, :column 10, :end-line 5568, :end-column 28, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([s]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ES6EntriesIterator, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5568, :end-line 5568, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil}, divide {:name cljs.core/divide, :file "cljs/core.cljs", :line 2230, :column 1, :end-line 2230, :end-column 16, :declared true, :meta {:file "cljs/core.cljs", :line 2230, :column 10, :end-line 2230, :end-column 16, :declared true}}, js-reserved-arr {:name cljs.core/js-reserved-arr, :file "cljs/core.cljs", :line 9795, :column 1, :end-line 9795, :end-column 31, :private true, :meta {:file "cljs/core.cljs", :line 9795, :column 16, :end-line 9795, :end-column 31, :private true}}, -pr-writer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 609, :column 4, :end-line 609, :end-column 14, :protocol cljs.core/IPrintWithWriter, :doc nil, :arglists (quote ([o writer opts]))}, :protocol cljs.core/IPrintWithWriter, :name cljs.core/-pr-writer, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([o writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 603, :end-line 609, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o writer opts])), :doc nil}, flush {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8567, :column 7, :end-line 8567, :end-column 12, :arglists (quote ([]))}, :name cljs.core/flush, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8567, :end-line 8567, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, set-from-indexed-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7999, :column 7, :end-line 7999, :end-column 27, :arglists (quote ([iseq]))}, :name cljs.core/set-from-indexed-seq, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([iseq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7999, :end-line 7999, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iseq]))}, take-while {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8167, :column 7, :end-line 8167, :end-column 17, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name cljs.core/take-while, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8167, :end-line 8167, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."}, vary-meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3427, :column 7, :end-line 3427, :end-column 16, :arglists (quote ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args])), :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d]), :arglists ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args]), :arglists-meta (nil nil nil nil nil nil)}}, :name cljs.core/vary-meta, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d]), :arglists ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args]), :arglists-meta (nil nil nil nil nil nil)}, :method-params ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil nil), :column 1, :line 3427, :end-line 3427, :max-fixed-arity 6, :fn-var true, :arglists ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args]), :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata."}, INext {:meta {:file "cljs/core.cljs", :line 461, :column 14, :end-line 461, :end-column 19, :doc "Protocol for accessing the next items of a collection.", :protocol-symbol true, :protocol-info {:methods {-next [[coll]]}}}, :protocol-symbol true, :name cljs.core/INext, :file "cljs/core.cljs", :end-column 19, :column 1, :line 461, :protocol-info {:methods {-next [[coll]]}}, :info nil, :end-line 461, :impls #{cljs.core/Cons cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/LazySeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range}, :doc "Protocol for accessing the next items of a collection."}, is_proto_ {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 218, :column 7, :end-line 218, :end-column 16, :arglists (quote ([x]))}, :name cljs.core/is_proto_, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 218, :end-line 218, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, ->t8245 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([nil-iter meta8246])), :file "cljs/core.cljs"}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t8245, :variadic false, :file "cljs/core.cljs", :method-params ([nil-iter meta8246]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :line 3455, :max-fixed-arity 2, :fn-var true, :arglists (quote ([nil-iter meta8246])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, START {:name cljs.core/START, :file "cljs/core.cljs", :line 3486, :column 1, :end-line 3486, :end-column 11, :meta {:file "cljs/core.cljs", :line 3486, :column 6, :end-line 3486, :end-column 11}}, ICounted {:meta {:file "cljs/core.cljs", :line 420, :column 14, :end-line 420, :end-column 22, :doc "Protocol for adding the ability to count a collection in constant time.", :protocol-symbol true, :protocol-info {:methods {-count [[coll]]}}}, :protocol-symbol true, :name cljs.core/ICounted, :file "cljs/core.cljs", :end-column 22, :column 1, :line 420, :protocol-info {:methods {-count [[coll]]}}, :info nil, :end-line 420, :impls #{nil cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/Subvec cljs.core/TransientHashMap cljs.core/ChunkBuffer cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/TransientArrayMap cljs.core/RSeq cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/ArrayChunk cljs.core/PersistentTreeSet cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding the ability to count a collection in constant time."}, IMapEntry {:meta {:file "cljs/core.cljs", :line 490, :column 14, :end-line 490, :end-column 23, :doc "Protocol for examining a map entry.", :protocol-symbol true, :protocol-info {:methods {-key [[coll]], -val [[coll]]}}}, :protocol-symbol true, :name cljs.core/IMapEntry, :file "cljs/core.cljs", :end-column 23, :column 1, :line 490, :protocol-info {:methods {-key [[coll]], -val [[coll]]}}, :info nil, :end-line 490, :impls #{cljs.core/BlackNode cljs.core/PersistentVector cljs.core/RedNode}, :doc "Protocol for examining a map entry."}, <= {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2251, :column 16, :end-line 2251, :end-column 18, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/<=, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2251, :ret-tag boolean, :end-line 2251, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false."}, conj! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3320, :column 7, :end-line 3320, :end-column 12, :arglists (quote ([] [coll] [tcoll val] [tcoll val & vals])), :doc "Adds x to the transient collection, and return coll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [coll] [tcoll val]), :arglists ([] [coll] [tcoll val] [tcoll val & vals]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/conj!, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [coll] [tcoll val]), :arglists ([] [coll] [tcoll val] [tcoll val & vals]), :arglists-meta (nil nil nil nil)}, :method-params ([] [coll] [tcoll val]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 3320, :end-line 3320, :max-fixed-arity 2, :fn-var true, :arglists ([] [coll] [tcoll val] [tcoll val & vals]), :doc "Adds x to the transient collection, and return coll. The 'addition'\n  may happen at different 'places' depending on the concrete type."}, -pop {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 508, :column 9, :end-line 508, :end-column 13, :tag clj, :protocol cljs.core/IStack, :doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop.", :arglists (quote ([coll]))}, :protocol cljs.core/IStack, :name cljs.core/-pop, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 502, :ret-tag clj, :end-line 508, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop."}, array-index-of-identical? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5625, :column 8, :end-line 5625, :end-column 33, :private true, :arglists (quote ([arr k]))}, :private true, :name cljs.core/array-index-of-identical?, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5625, :end-line 5625, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, repeatedly {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4282, :column 7, :end-line 4282, :end-column 17, :arglists (quote ([f] [n f])), :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [n f]), :arglists ([f] [n f]), :arglists-meta (nil nil)}}, :name cljs.core/repeatedly, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [n f]), :arglists ([f] [n f]), :arglists-meta (nil nil)}, :method-params ([f] [n f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4282, :end-line 4282, :max-fixed-arity 2, :fn-var true, :arglists ([f] [n f]), :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it"}, zipmap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8099, :column 7, :end-line 8099, :end-column 13, :arglists (quote ([keys vals])), :doc "Returns a map with the keys mapped to the corresponding vals."}, :name cljs.core/zipmap, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([keys vals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8099, :end-line 8099, :max-fixed-arity 2, :fn-var true, :arglists (quote ([keys vals])), :doc "Returns a map with the keys mapped to the corresponding vals."}, IStack {:meta {:file "cljs/core.cljs", :line 502, :column 14, :end-line 502, :end-column 20, :doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures.", :protocol-symbol true, :protocol-info {:methods {-peek [[coll]], -pop [[coll]]}}}, :protocol-symbol true, :name cljs.core/IStack, :file "cljs/core.cljs", :end-column 20, :column 1, :line 502, :protocol-info {:methods {-peek [[coll]], -pop [[coll]]}}, :info nil, :end-line 502, :impls #{cljs.core/PersistentQueue cljs.core/BlackNode cljs.core/EmptyList cljs.core/Subvec cljs.core/PersistentVector cljs.core/List cljs.core/RedNode}, :doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures."}, -remove-watch {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 624, :column 4, :end-line 624, :end-column 17, :protocol cljs.core/IWatchable, :doc "Removes watcher that corresponds to key from this.", :arglists (quote ([this key]))}, :protocol cljs.core/IWatchable, :name cljs.core/-remove-watch, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([this key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 617, :end-line 624, :max-fixed-arity 2, :fn-var true, :arglists (quote ([this key])), :doc "Removes watcher that corresponds to key from this."}, IVolatile {:meta {:file "cljs/core.cljs", :line 705, :column 14, :end-line 705, :end-column 23, :doc "Protocol for adding volatile functionality.", :protocol-symbol true, :protocol-info {:methods {-vreset! [[o new-value]]}}}, :protocol-symbol true, :name cljs.core/IVolatile, :file "cljs/core.cljs", :end-column 23, :column 1, :line 705, :protocol-info {:methods {-vreset! [[o new-value]]}}, :info nil, :end-line 705, :impls #{cljs.core/Volatile}, :doc "Protocol for adding volatile functionality."}, remove {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4382, :column 7, :end-line 4382, :end-column 13, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name cljs.core/remove, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4382, :end-line 4382, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."}, ->BitmapIndexedNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6071, :column 10, :end-line 6071, :end-column 27, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([edit bitmap arr]))}, :protocols #{cljs.core/Object}, :name cljs.core/->BitmapIndexedNode, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([edit bitmap arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6071, :end-line 6071, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit bitmap arr])), :skip-protocol-flag nil}, * {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2223, :column 15, :end-line 2223, :end-column 16, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/*, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 2223, :ret-tag number, :end-line 2223, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the product of nums. (*) returns 1."}, re-pattern {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8525, :column 7, :end-line 8525, :end-column 17, :arglists (quote ([s])), :doc "Returns an instance of RegExp which has compiled the provided string."}, :name cljs.core/re-pattern, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8525, :end-line 8525, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Returns an instance of RegExp which has compiled the provided string."}, min {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2298, :column 15, :end-line 2298, :end-column 18, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns the least of the nums.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/min, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2298, :ret-tag number, :end-line 2298, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns the least of the nums."}, array-index-of-nil? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5595, :column 8, :end-line 5595, :end-column 27, :private true, :arglists (quote ([arr]))}, :private true, :name cljs.core/array-index-of-nil?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5595, :end-line 5595, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr]))}, -persistent! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 636, :column 9, :end-line 636, :end-column 21, :tag clj, :protocol cljs.core/ITransientCollection, :doc "Creates a persistent data structure from tcoll and returns it.", :arglists (quote ([tcoll]))}, :protocol cljs.core/ITransientCollection, :name cljs.core/-persistent!, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 632, :ret-tag clj, :end-line 636, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([tcoll])), :doc "Creates a persistent data structure from tcoll and returns it."}, -nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 444, :column 4, :end-line 444, :end-column 8, :protocol cljs.core/IIndexed, :doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied.", :arglists (quote ([coll n] [coll n not-found])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}}, :protocol cljs.core/IIndexed, :name cljs.core/-nth, :variadic false, :file "cljs/core.cljs", :end-column 8, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 442, :end-line 444, :max-fixed-arity 3, :fn-var true, :arglists ([coll n] [coll n not-found]), :doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied."}, pop! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3355, :column 7, :end-line 3355, :end-column 11, :arglists (quote ([tcoll])), :doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns coll"}, :name cljs.core/pop!, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3355, :end-line 3355, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tcoll])), :doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns coll"}, chunk-append {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3126, :column 7, :end-line 3126, :end-column 19, :arglists (quote ([b x]))}, :name cljs.core/chunk-append, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([b x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3126, :end-line 3126, :max-fixed-arity 2, :fn-var true, :arglists (quote ([b x]))}, prn-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8714, :column 7, :end-line 8714, :end-column 14, :arglists (quote ([& objs])), :doc "Same as pr-str followed by (newline)", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/prn-str, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8714, :end-line 8714, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "Same as pr-str followed by (newline)"}, IReversible {:meta {:file "cljs/core.cljs", :line 574, :column 14, :end-line 574, :end-column 25, :doc "Protocol for reversing a seq.", :protocol-symbol true, :protocol-info {:methods {-rseq [[coll]]}}}, :protocol-symbol true, :name cljs.core/IReversible, :file "cljs/core.cljs", :end-column 25, :column 1, :line 574, :protocol-info {:methods {-rseq [[coll]]}}, :info nil, :end-line 574, :impls #{cljs.core/IndexedSeq cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet}, :doc "Protocol for reversing a seq."}, reversible? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2763, :column 16, :end-line 2763, :end-column 27, :tag boolean, :arglists (quote ([coll])), :doc "Returns true if coll satisfies? IReversible."}, :name cljs.core/reversible?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2763, :ret-tag boolean, :end-line 2763, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([coll])), :doc "Returns true if coll satisfies? IReversible."}, -realized? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 614, :column 13, :end-line 614, :end-column 23, :tag boolean, :protocol cljs.core/IPending, :doc "Returns true if a value for d has been produced, false otherwise.", :arglists (quote ([d]))}, :protocol cljs.core/IPending, :name cljs.core/-realized?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 611, :ret-tag boolean, :end-line 614, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([d])), :doc "Returns true if a value for d has been produced, false otherwise."}, -add-watch {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 621, :column 4, :end-line 621, :end-column 14, :protocol cljs.core/IWatchable, :doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch.", :arglists (quote ([this key f]))}, :protocol cljs.core/IWatchable, :name cljs.core/-add-watch, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([this key f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 617, :end-line 621, :max-fixed-arity 3, :fn-var true, :arglists (quote ([this key f])), :doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch."}, -deref-with-timeout {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 523, :column 4, :end-line 523, :end-column 23, :protocol cljs.core/IDerefWithTimeout, :doc nil, :arglists (quote ([o msec timeout-val]))}, :protocol cljs.core/IDerefWithTimeout, :name cljs.core/-deref-with-timeout, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([o msec timeout-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 522, :end-line 523, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o msec timeout-val])), :doc nil}, conj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1519, :column 7, :end-line 1519, :end-column 11, :arglists (quote ([] [coll] [coll x] [coll x & xs])), :doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [coll] [coll x]), :arglists ([] [coll] [coll x] [coll x & xs]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/conj, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [coll] [coll x]), :arglists ([] [coll] [coll x] [coll x & xs]), :arglists-meta (nil nil nil nil)}, :method-params ([] [coll] [coll x]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 1519, :end-line 1519, :max-fixed-arity 2, :fn-var true, :arglists ([] [coll] [coll x] [coll x & xs]), :doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type."}, -sorted-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 582, :column 9, :end-line 582, :end-column 20, :tag clj, :protocol cljs.core/ISorted, :doc "Returns a sorted seq from coll in either ascending or descending order.", :arglists (quote ([coll ascending?]))}, :protocol cljs.core/ISorted, :name cljs.core/-sorted-seq, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([coll ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 579, :ret-tag clj, :end-line 582, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll ascending?])), :doc "Returns a sorted seq from coll in either ascending or descending order."}, flatten1 {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4329, :column 8, :end-line 4329, :end-column 16, :private true, :arglists (quote ([colls])), :doc "Take a collection of collections, and return a lazy seq\n  of items from the inner collection"}, :private true, :name cljs.core/flatten1, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4329, :end-line 4329, :max-fixed-arity 1, :fn-var true, :arglists (quote ([colls])), :doc "Take a collection of collections, and return a lazy seq\n  of items from the inner collection"}, transduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2190, :column 7, :end-line 2190, :end-column 16, :arglists (quote ([xform f coll] [xform f init coll])), :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([xform f coll] [xform f init coll]), :arglists ([xform f coll] [xform f init coll]), :arglists-meta (nil nil)}}, :name cljs.core/transduce, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([xform f coll] [xform f init coll]), :arglists ([xform f coll] [xform f init coll]), :arglists-meta (nil nil)}, :method-params ([xform f coll] [xform f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2190, :end-line 2190, :max-fixed-arity 4, :fn-var true, :arglists ([xform f coll] [xform f init coll]), :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items."}, fixture1 {:name cljs.core/fixture1, :file "cljs/core.cljs", :line 8968, :column 1, :end-line 8968, :end-column 14, :meta {:file "cljs/core.cljs", :line 8968, :column 6, :end-line 8968, :end-column 14}}, -swap! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 702, :column 4, :end-line 702, :end-column 10, :protocol cljs.core/ISwap, :doc "Swaps the value of o to be (apply f current-value-of-atom args).", :arglists (quote ([o f] [o f a] [o f a b] [o f a b xs])), :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([o f] [o f a] [o f a b] [o f a b xs]), :arglists ([o f] [o f a] [o f a b] [o f a b xs]), :arglists-meta (nil nil nil nil)}}, :protocol cljs.core/ISwap, :name cljs.core/-swap!, :variadic false, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([o f] [o f a] [o f a b] [o f a b xs]), :arglists ([o f] [o f a] [o f a b] [o f a b xs]), :arglists-meta (nil nil nil nil)}, :method-params ([o f] [o f a] [o f a b] [o f a b xs]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 700, :end-line 702, :max-fixed-arity 5, :fn-var true, :arglists ([o f] [o f a] [o f a b] [o f a b xs]), :doc "Swaps the value of o to be (apply f current-value-of-atom args)."}, *print-length* {:name cljs.core/*print-length*, :file "cljs/core.cljs", :line 96, :column 1, :end-line 102, :end-column 17, :dynamic true, :doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false.", :meta {:file "cljs/core.cljs", :line 102, :column 3, :end-line 102, :end-column 17, :dynamic true, :doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false."}}, js-delete {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1909, :column 7, :end-line 1909, :end-column 16, :arglists (quote ([obj key])), :doc "Delete a property from a JavaScript object."}, :name cljs.core/js-delete, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([obj key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1909, :end-line 1909, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj key])), :doc "Delete a property from a JavaScript object."}, truth_ {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 151, :column 7, :end-line 151, :end-column 13, :arglists (quote ([x])), :doc "Internal - do not use!"}, :name cljs.core/truth_, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 151, :end-line 151, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Internal - do not use!"}, array-index-of {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5641, :column 7, :end-line 5641, :end-column 21, :arglists (quote ([arr k]))}, :name cljs.core/array-index-of, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5641, :end-line 5641, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, ->MultiFn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9390, :column 10, :end-line 9390, :end-column 17, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :factory :positional, :arglists (quote ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]))}, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :name cljs.core/->MultiFn, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 9390, :end-line 9390, :max-fixed-arity 8, :fn-var true, :arglists (quote ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy])), :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}}, key->js {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9086, :column 7, :end-line 9086, :end-column 14, :arglists (quote ([k]))}, :name cljs.core/key->js, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9086, :end-line 9086, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, ->MultiStepper {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3552, :column 10, :end-line 3552, :end-column 22, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([xform iters nexts]))}, :protocols #{cljs.core/Object}, :name cljs.core/->MultiStepper, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([xform iters nexts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3552, :end-line 3552, :max-fixed-arity 3, :fn-var true, :arglists (quote ([xform iters nexts])), :skip-protocol-flag nil}, IEncodeJS {:meta {:file "cljs/core.cljs", :line 9079, :column 14, :end-line 9079, :end-column 23, :doc nil, :protocol-symbol true, :protocol-info {:methods {-clj->js [[x]], -key->js [[x]]}}}, :protocol-symbol true, :name cljs.core/IEncodeJS, :file "cljs/core.cljs", :end-column 23, :column 1, :line 9079, :protocol-info {:methods {-clj->js [[x]], -key->js [[x]]}}, :info nil, :end-line 9079, :impls #{}, :doc nil}, new-path {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4569, :column 8, :end-line 4569, :end-column 16, :private true, :arglists (quote ([edit level node]))}, :private true, :name cljs.core/new-path, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([edit level node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4569, :end-line 4569, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit level node]))}, compare-and-set! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3968, :column 7, :end-line 3968, :end-column 23, :arglists (quote ([a oldval newval])), :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false."}, :name cljs.core/compare-and-set!, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([a oldval newval]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3968, :end-line 3968, :max-fixed-arity 3, :fn-var true, :arglists (quote ([a oldval newval])), :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false."}, array-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1418, :column 7, :end-line 1418, :end-column 16, :arglists (quote ([array] [array i])), :doc "Create a seq from a JavaScript array.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([array] [array i]), :arglists ([array] [array i]), :arglists-meta (nil nil)}}, :name cljs.core/array-seq, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([array] [array i]), :arglists ([array] [array i]), :arglists-meta (nil nil)}, :method-params ([array] [array i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1418, :end-line 1418, :max-fixed-arity 2, :fn-var true, :arglists ([array] [array i]), :doc "Create a seq from a JavaScript array."}, array-copy-downward {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1922, :column 8, :end-line 1922, :end-column 27, :private true, :arglists (quote ([from i to j len]))}, :private true, :name cljs.core/array-copy-downward, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([from i to j len]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1922, :end-line 1922, :max-fixed-arity 5, :fn-var true, :arglists (quote ([from i to j len]))}, pack-array-node {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6269, :column 8, :end-line 6269, :end-column 23, :private true, :arglists (quote ([array-node edit idx]))}, :private true, :name cljs.core/pack-array-node, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([array-node edit idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6269, :end-line 6269, :max-fixed-arity 3, :fn-var true, :arglists (quote ([array-node edit idx]))}, interleave {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4294, :column 7, :end-line 4294, :end-column 17, :arglists (quote ([c1 c2] [c1 c2 & colls])), :doc "Returns a lazy seq of the first item in each coll, then the second etc.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([c1 c2]), :arglists ([c1 c2] [c1 c2 & colls]), :arglists-meta (nil nil)}}, :name cljs.core/interleave, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([c1 c2]), :arglists ([c1 c2] [c1 c2 & colls]), :arglists-meta (nil nil)}, :method-params ([c1 c2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4294, :end-line 4294, :max-fixed-arity 2, :fn-var true, :arglists ([c1 c2] [c1 c2 & colls]), :doc "Returns a lazy seq of the first item in each coll, then the second etc."}, print-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8758, :column 7, :end-line 8758, :end-column 16, :arglists (quote ([m print-one writer opts]))}, :name cljs.core/print-map, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([m print-one writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8758, :end-line 8758, :max-fixed-arity 4, :fn-var true, :arglists (quote ([m print-one writer opts]))}, map? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1871, :column 16, :end-line 1871, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies IMap"}, :name cljs.core/map?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1871, :ret-tag boolean, :end-line 1871, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IMap"}, *err* {:name cljs.core/*err*, :file "cljs/core.cljs", :line 38, :column 1, :end-line 40, :end-column 8, :dynamic true, :meta {:file "cljs/core.cljs", :line 40, :column 3, :end-line 40, :end-column 8, :dynamic true}}, m3-C1 {:name cljs.core/m3-C1, :file "cljs/core.cljs", :line 757, :column 1, :end-line 757, :end-column 11, :meta {:file "cljs/core.cljs", :line 757, :column 6, :end-line 757, :end-column 11}}, get {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1659, :column 7, :end-line 1659, :end-column 10, :arglists (quote ([o k] [o k not-found])), :doc "Returns the value mapped to key, not-found or nil if key not present.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([o k] [o k not-found]), :arglists ([o k] [o k not-found]), :arglists-meta (nil nil)}}, :name cljs.core/get, :variadic false, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([o k] [o k not-found]), :arglists ([o k] [o k not-found]), :arglists-meta (nil nil)}, :method-params ([o k] [o k not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1659, :end-line 1659, :max-fixed-arity 3, :fn-var true, :arglists ([o k] [o k not-found]), :doc "Returns the value mapped to key, not-found or nil if key not present."}, identity {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2175, :column 7, :end-line 2175, :end-column 15, :arglists (quote ([x])), :doc "Returns its argument."}, :name cljs.core/identity, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2175, :end-line 2175, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns its argument."}, into {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4413, :column 7, :end-line 4413, :end-column 11, :arglists (quote ([to from] [to xform from])), :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([to from] [to xform from]), :arglists ([to from] [to xform from]), :arglists-meta (nil nil)}}, :name cljs.core/into, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([to from] [to xform from]), :arglists ([to from] [to xform from]), :arglists-meta (nil nil)}, :method-params ([to from] [to xform from]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4413, :end-line 4413, :max-fixed-arity 3, :fn-var true, :arglists ([to from] [to xform from]), :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied."}, long {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2416, :column 7, :end-line 2416, :end-column 11, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, :name cljs.core/long, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2416, :end-line 2416, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, double {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2317, :column 15, :end-line 2317, :end-column 21, :tag number, :arglists (quote ([x]))}, :name cljs.core/double, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2317, :ret-tag number, :end-line 2317, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, volatile? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4005, :column 7, :end-line 4005, :end-column 16, :arglists (quote ([x])), :doc "Returns true if x is a volatile."}, :name cljs.core/volatile?, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4005, :end-line 4005, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a volatile."}, ChunkBuffer {:num-fields 2, :protocols #{cljs.core/Object cljs.core/ICounted}, :name cljs.core/ChunkBuffer, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 3008, :record false, :end-line 3008, :skip-protocol-flag #{cljs.core/ICounted}}, -key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 492, :column 4, :end-line 492, :end-column 8, :protocol cljs.core/IMapEntry, :doc "Returns the key of the map entry.", :arglists (quote ([coll]))}, :protocol cljs.core/IMapEntry, :name cljs.core/-key, :variadic false, :file "cljs/core.cljs", :end-column 8, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 490, :end-line 492, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the key of the map entry."}, nfirst {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1492, :column 7, :end-line 1492, :end-column 13, :arglists (quote ([coll])), :doc "Same as (next (first x))"}, :name cljs.core/nfirst, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1492, :end-line 1492, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (next (first x))"}, StringBufferWriter {:num-fields 1, :protocols #{cljs.core/IWriter}, :name cljs.core/StringBufferWriter, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 718, :record false, :end-line 718, :skip-protocol-flag #{cljs.core/IWriter}}, meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1799, :column 7, :end-line 1799, :end-column 11, :arglists (quote ([o])), :doc "Returns the metadata of obj, returns nil if there is no metadata."}, :name cljs.core/meta, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1799, :end-line 1799, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the metadata of obj, returns nil if there is no metadata."}, tv-editable-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5110, :column 8, :end-line 5110, :end-column 24, :private true, :arglists (quote ([tl]))}, :private true, :name cljs.core/tv-editable-tail, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([tl]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5110, :end-line 5110, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tl]))}, -kv-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 546, :column 4, :end-line 546, :end-column 14, :protocol cljs.core/IKVReduce, :doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments.", :arglists (quote ([coll f init]))}, :protocol cljs.core/IKVReduce, :name cljs.core/-kv-reduce, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 543, :end-line 546, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll f init])), :doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments."}, IHash {:meta {:file "cljs/core.cljs", :line 555, :column 14, :end-line 555, :end-column 19, :doc "Protocol for adding hashing functionality to a type.", :protocol-symbol true, :protocol-info {:methods {-hash [[o]]}}}, :protocol-symbol true, :name cljs.core/IHash, :file "cljs/core.cljs", :end-column 19, :column 1, :line 555, :protocol-info {:methods {-hash [[o]]}}, :info nil, :end-line 555, :impls #{cljs.core/Namespace cljs.core/PersistentHashMap cljs.core/MultiFn cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/TaggedLiteral default cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/LazyTransformer cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding hashing functionality to a type."}, bit-and-not {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2475, :column 7, :end-line 2475, :end-column 18, :arglists (quote ([x y] [x y & more])), :doc "Bitwise and", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}}, :name cljs.core/bit-and-not, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2475, :end-line 2475, :max-fixed-arity 2, :fn-var true, :arglists ([x y] [x y & more]), :doc "Bitwise and"}, var? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 998, :column 7, :end-line 998, :end-column 11, :arglists (quote ([v])), :doc "Returns true if v is of type cljs.core.Var"}, :name cljs.core/var?, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 998, :end-line 998, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "Returns true if v is of type cljs.core.Var"}, -comparator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 593, :column 4, :end-line 593, :end-column 15, :protocol cljs.core/ISorted, :doc "Returns the comparator for coll.", :arglists (quote ([coll]))}, :protocol cljs.core/ISorted, :name cljs.core/-comparator, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 579, :end-line 593, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the comparator for coll."}, unchecked-add-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2332, :column 15, :end-line 2332, :end-column 32, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/unchecked-add-int, :variadic true, :file "cljs/core.cljs", :end-column 32, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 2332, :ret-tag number, :end-line 2332, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the sum of nums. (+) returns 0."}, hash-ordered-coll {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1145, :column 15, :end-line 1145, :end-column 32, :tag number, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms."}, :name cljs.core/hash-ordered-coll, :variadic false, :file "cljs/core.cljs", :end-column 32, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1145, :ret-tag number, :end-line 1145, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms."}, extend-object! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2634, :column 8, :end-line 2634, :end-column 22, :private true, :arglists (quote ([obj fn-map])), :doc "Takes a JavaScript object and a map of names to functions and\n  attaches said functions as methods on the object.  Any references to\n  JavaScript's implicit this (via the this-as macro) will resolve to the\n  object that the function is attached."}, :private true, :name cljs.core/extend-object!, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([obj fn-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2634, :end-line 2634, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj fn-map])), :doc "Takes a JavaScript object and a map of names to functions and\n  attaches said functions as methods on the object.  Any references to\n  JavaScript's implicit this (via the this-as macro) will resolve to the\n  object that the function is attached."}, do-assoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4622, :column 8, :end-line 4622, :end-column 16, :private true, :arglists (quote ([pv level node i val]))}, :private true, :name cljs.core/do-assoc, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([pv level node i val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4622, :end-line 4622, :max-fixed-arity 5, :fn-var true, :arglists (quote ([pv level node i val]))}, reset-meta! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8914, :column 7, :end-line 8914, :end-column 18, :arglists (quote ([iref m])), :doc "Atomically resets the metadata for an atom"}, :name cljs.core/reset-meta!, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([iref m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8914, :end-line 8914, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref m])), :doc "Atomically resets the metadata for an atom"}, ->KeySeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7596, :column 10, :end-line 7596, :end-column 16, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([mseq _meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->KeySeq, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([mseq _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7596, :end-line 7596, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mseq _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, IEquiv {:meta {:file "cljs/core.cljs", :line 550, :column 14, :end-line 550, :end-column 20, :doc "Protocol for adding value comparison functionality to a type.", :protocol-symbol true, :protocol-info {:methods {-equiv [[o other]]}}}, :protocol-symbol true, :name cljs.core/IEquiv, :file "cljs/core.cljs", :end-column 20, :column 1, :line 550, :protocol-info {:methods {-equiv [[o other]]}}, :info nil, :end-line 550, :impls #{cljs.core/Namespace cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq js/Date cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/TaggedLiteral number default cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/NeverEquiv cljs.core/LazyTransformer cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding value comparison functionality to a type."}, tree-map-kv-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7026, :column 8, :end-line 7026, :end-column 26, :private true, :arglists (quote ([node f init]))}, :private true, :name cljs.core/tree-map-kv-reduce, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([node f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7026, :end-line 7026, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node f init]))}, cycle {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4262, :column 7, :end-line 4262, :end-column 12, :arglists (quote ([coll])), :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll."}, :name cljs.core/cycle, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4262, :end-line 4262, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll."}, -deref {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 519, :column 4, :end-line 519, :end-column 10, :protocol cljs.core/IDeref, :doc "Returns the value of the reference o.", :arglists (quote ([o]))}, :protocol cljs.core/IDeref, :name cljs.core/-deref, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 517, :end-line 519, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the value of the reference o."}, pr-writer-ex-info {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9658, :column 8, :end-line 9658, :end-column 25, :private true, :arglists (quote ([obj writer opts]))}, :private true, :name cljs.core/pr-writer-ex-info, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([obj writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9658, :end-line 9658, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts]))}, empty? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1835, :column 16, :end-line 1835, :end-column 22, :tag boolean, :arglists (quote ([coll])), :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))"}, :name cljs.core/empty?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1835, :ret-tag boolean, :end-line 1835, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([coll])), :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))"}, TaggedLiteral {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/ILookup}, :name cljs.core/TaggedLiteral, :file "cljs/core.cljs", :end-column 23, :type true, :column 10, :line 9753, :record false, :end-line 9753, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/ILookup}}, short {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2315, :column 15, :end-line 2315, :end-column 20, :tag number, :arglists (quote ([x]))}, :name cljs.core/short, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2315, :ret-tag number, :end-line 2315, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, -clj->js {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9080, :column 4, :end-line 9080, :end-column 12, :protocol cljs.core/IEncodeJS, :doc "Recursively transforms clj values to JavaScript", :arglists (quote ([x]))}, :protocol cljs.core/IEncodeJS, :name cljs.core/-clj->js, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9079, :end-line 9080, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Recursively transforms clj values to JavaScript"}, -chunked-first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 675, :column 4, :end-line 675, :end-column 18, :protocol cljs.core/IChunkedSeq, :doc "Returns the first chunk in coll.", :arglists (quote ([coll]))}, :protocol cljs.core/IChunkedSeq, :name cljs.core/-chunked-first, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 673, :end-line 675, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the first chunk in coll."}, filterv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4443, :column 7, :end-line 4443, :end-column 14, :arglists (quote ([pred coll])), :doc "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects."}, :name cljs.core/filterv, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4443, :end-line 4443, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects."}, ->TaggedLiteral {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9753, :column 10, :end-line 9753, :end-column 23, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/ILookup}, :factory :positional, :arglists (quote ([tag form]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/ILookup}, :name cljs.core/->TaggedLiteral, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([tag form]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 9753, :end-line 9753, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag form])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/ILookup}}, tv-editable-root {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5107, :column 8, :end-line 5107, :end-column 24, :private true, :arglists (quote ([node]))}, :private true, :name cljs.core/tv-editable-root, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5107, :end-line 5107, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, hash {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 831, :column 7, :end-line 831, :end-column 11, :arglists (quote ([o])), :doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =."}, :name cljs.core/hash, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 831, :end-line 831, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =."}, quot {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2445, :column 7, :end-line 2445, :end-column 11, :arglists (quote ([n d])), :doc "quot[ient] of dividing numerator by denominator."}, :name cljs.core/quot, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2445, :end-line 2445, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "quot[ient] of dividing numerator by denominator."}, ns-interns* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9912, :column 7, :end-line 9912, :end-column 18, :arglists (quote ([sym]))}, :name cljs.core/ns-interns*, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9912, :end-line 9912, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym]))}, unchecked-double {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2323, :column 15, :end-line 2323, :end-column 31, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-double, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2323, :ret-tag number, :end-line 2323, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, *target* {:meta {:file "cljs/core.cljs", :line 27, :column 3, :end-line 27, :end-column 11, :dynamic true, :doc "Var bound to the name value of the compiler build :target option.\n  For example, if the compiler build :target is :nodejs, *target* will be bound\n  to \"nodejs\". *target* is a Google Closure define and can be set by compiler\n  :closure-defines option.", :jsdoc ["@define {string}"]}, :name cljs.core/*target*, :file "cljs/core.cljs", :end-column 11, :column 1, :dynamic true, :line 20, :end-line 27, :doc "Var bound to the name value of the compiler build :target option.\n  For example, if the compiler build :target is :nodejs, *target* will be bound\n  to \"nodejs\". *target* is a Google Closure define and can be set by compiler\n  :closure-defines option.", :jsdoc ["@define {string}"]}, ->ChunkedCons {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3057, :column 10, :end-line 3057, :end-column 21, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([chunk more meta __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->ChunkedCons, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([chunk more meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3057, :end-line 3057, :max-fixed-arity 4, :fn-var true, :arglists (quote ([chunk more meta __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}}, ranged-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4658, :column 7, :end-line 4658, :end-column 22, :arglists (quote ([v start end]))}, :name cljs.core/ranged-iterator, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4658, :end-line 4658, :max-fixed-arity 3, :fn-var true, :arglists (quote ([v start end]))}, ITransientVector {:meta {:file "cljs/core.cljs", :line 650, :column 14, :end-line 650, :end-column 30, :doc "Protocol for adding vector functionality to transient collections.", :protocol-symbol true, :protocol-info {:methods {-assoc-n! [[tcoll n val]], -pop! [[tcoll]]}}}, :protocol-symbol true, :name cljs.core/ITransientVector, :file "cljs/core.cljs", :end-column 30, :column 1, :line 650, :protocol-info {:methods {-assoc-n! [[tcoll n val]], -pop! [[tcoll]]}}, :info nil, :end-line 650, :impls #{cljs.core/TransientVector}, :doc "Protocol for adding vector functionality to transient collections."}, key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7659, :column 7, :end-line 7659, :end-column 10, :arglists (quote ([map-entry])), :doc "Returns the key of the map entry."}, :name cljs.core/key, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([map-entry]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7659, :end-line 7659, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-entry])), :doc "Returns the key of the map entry."}, longs {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2433, :column 7, :end-line 2433, :end-column 12, :arglists (quote ([x]))}, :name cljs.core/longs, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2433, :end-line 2433, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, not= {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3443, :column 16, :end-line 3443, :end-column 20, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Same as (not (= obj1 obj2))", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/not=, :variadic true, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 3443, :ret-tag boolean, :end-line 3443, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Same as (not (= obj1 obj2))"}, string? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 197, :column 16, :end-line 197, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript string."}, :name cljs.core/string?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 197, :ret-tag boolean, :end-line 197, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript string."}, es6-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1106, :column 7, :end-line 1106, :end-column 19, :arglists (quote ([coll])), :doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll."}, :name cljs.core/es6-iterator, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1106, :end-line 1106, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll."}, Delay {:num-fields 2, :protocols #{cljs.core/IPending cljs.core/IDeref}, :name cljs.core/Delay, :file "cljs/core.cljs", :end-column 15, :type true, :column 10, :line 8973, :record false, :end-line 8973, :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref}}, munge-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9835, :column 8, :end-line 9835, :end-column 17, :private true, :arglists (quote ([name]))}, :private true, :name cljs.core/munge-str, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9835, :end-line 9835, :max-fixed-arity 1, :fn-var true, :arglists (quote ([name]))}, pr-str-with-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8679, :column 7, :end-line 8679, :end-column 23, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects to a string, observing all the\n  options given in opts"}, :name cljs.core/pr-str-with-opts, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8679, :end-line 8679, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects to a string, observing all the\n  options given in opts"}, m3-C2 {:name cljs.core/m3-C2, :file "cljs/core.cljs", :line 758, :column 1, :end-line 758, :end-column 11, :meta {:file "cljs/core.cljs", :line 758, :column 6, :end-line 758, :end-column 11}}, ->Symbol {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 894, :column 10, :end-line 894, :end-column 16, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([ns name str _hash _meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :name cljs.core/->Symbol, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([ns name str _hash _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 894, :end-line 894, :max-fixed-arity 5, :fn-var true, :arglists (quote ([ns name str _hash _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}}, *print-newline* {:name cljs.core/*print-newline*, :file "cljs/core.cljs", :line 65, :column 1, :end-line 70, :end-column 18, :dynamic true, :doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects.", :meta {:file "cljs/core.cljs", :line 70, :column 3, :end-line 70, :end-column 18, :dynamic true, :doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects."}}, unchecked-multiply-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2369, :column 15, :end-line 2369, :end-column 37, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/unchecked-multiply-int, :variadic true, :file "cljs/core.cljs", :end-column 37, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 2369, :ret-tag number, :end-line 2369, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the product of nums. (*) returns 1."}, t5612 {:num-fields 2, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t5612, :file "cljs/core.cljs", :type true, :anonymous true, :column 3, :line 3455, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, chunk-rest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3135, :column 7, :end-line 3135, :end-column 17, :arglists (quote ([s]))}, :name cljs.core/chunk-rest, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3135, :end-line 3135, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, remove-all-methods {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9577, :column 7, :end-line 9577, :end-column 25, :arglists (quote ([multifn])), :doc "Removes all of the methods of multimethod."}, :name cljs.core/remove-all-methods, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9577, :end-line 9577, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Removes all of the methods of multimethod."}, trampoline {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9165, :column 7, :end-line 9165, :end-column 17, :arglists (quote ([f] [f & args])), :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([f]), :arglists ([f] [f & args]), :arglists-meta (nil nil)}}, :name cljs.core/trampoline, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([f]), :arglists ([f] [f & args]), :arglists-meta (nil nil)}, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9165, :end-line 9165, :max-fixed-arity 1, :fn-var true, :arglists ([f] [f & args]), :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns."}, pr-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 118, :column 8, :end-line 118, :end-column 15, :private true, :arglists (quote ([]))}, :private true, :name cljs.core/pr-opts, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 118, :end-line 118, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, *1 {:name cljs.core/*1, :file "cljs/core.cljs", :line 135, :column 1, :end-line 137, :end-column 5, :doc "bound in a repl thread to the most recent value printed", :meta {:file "cljs/core.cljs", :line 137, :column 3, :end-line 137, :end-column 5, :doc "bound in a repl thread to the most recent value printed"}}, vec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4870, :column 7, :end-line 4870, :end-column 10, :arglists (quote ([coll])), :doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified."}, :name cljs.core/vec, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4870, :end-line 4870, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified."}, *print-meta* {:name cljs.core/*print-meta*, :file "cljs/core.cljs", :line 80, :column 1, :end-line 86, :end-column 15, :dynamic true, :doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false.", :meta {:file "cljs/core.cljs", :line 86, :column 3, :end-line 86, :end-column 15, :dynamic true, :doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false."}}, -notify-watches {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 619, :column 4, :end-line 619, :end-column 19, :protocol cljs.core/IWatchable, :doc "Calls all watchers with this, oldval and newval.", :arglists (quote ([this oldval newval]))}, :protocol cljs.core/IWatchable, :name cljs.core/-notify-watches, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([this oldval newval]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 617, :end-line 619, :max-fixed-arity 3, :fn-var true, :arglists (quote ([this oldval newval])), :doc "Calls all watchers with this, oldval and newval."}, MultiFn {:num-fields 8, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :name cljs.core/MultiFn, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 9390, :record false, :end-line 9390, :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}}, int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2406, :column 7, :end-line 2406, :end-column 10, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, :name cljs.core/int, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2406, :end-line 2406, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, ->ValSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7664, :column 10, :end-line 7664, :end-column 16, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([mseq _meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ValSeq, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([mseq _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7664, :end-line 7664, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mseq _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, rand {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9181, :column 7, :end-line 9181, :end-column 11, :arglists (quote ([] [n])), :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [n]), :arglists ([] [n]), :arglists-meta (nil nil)}}, :name cljs.core/rand, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [n]), :arglists ([] [n]), :arglists-meta (nil nil)}, :method-params ([] [n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9181, :end-line 9181, :max-fixed-arity 1, :fn-var true, :arglists ([] [n]), :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive)."}, second {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1482, :column 7, :end-line 1482, :end-column 13, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, :name cljs.core/second, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1482, :end-line 1482, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, find-ns-obj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9895, :column 7, :end-line 9895, :end-column 18, :arglists (quote ([ns]))}, :name cljs.core/find-ns-obj, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([ns]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9895, :end-line 9895, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ns]))}, IEditableCollection {:meta {:file "cljs/core.cljs", :line 627, :column 14, :end-line 627, :end-column 33, :doc "Protocol for collections which can transformed to transients.", :protocol-symbol true, :protocol-info {:methods {-as-transient [[coll]]}}}, :protocol-symbol true, :name cljs.core/IEditableCollection, :file "cljs/core.cljs", :end-column 33, :column 1, :line 627, :protocol-info {:methods {-as-transient [[coll]]}}, :info nil, :end-line 627, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/PersistentVector cljs.core/PersistentHashSet}, :doc "Protocol for collections which can transformed to transients."}, hash-combine {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 857, :column 7, :end-line 857, :end-column 19, :arglists (quote ([seed hash]))}, :name cljs.core/hash-combine, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([seed hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 857, :end-line 857, :max-fixed-arity 2, :fn-var true, :arglists (quote ([seed hash]))}, > {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2263, :column 16, :end-line 2263, :end-column 17, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/>, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2263, :ret-tag boolean, :end-line 2263, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false."}, -name {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 687, :column 12, :end-line 687, :end-column 17, :tag string, :protocol cljs.core/INamed, :doc "Returns the name String of x.", :arglists (quote ([x]))}, :protocol cljs.core/INamed, :name cljs.core/-name, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 685, :ret-tag string, :end-line 687, :max-fixed-arity 1, :tag string, :fn-var true, :arglists (quote ([x])), :doc "Returns the name String of x."}, replace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8040, :column 7, :end-line 8040, :end-column 14, :arglists (quote ([smap] [smap coll])), :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([smap] [smap coll]), :arglists ([smap] [smap coll]), :arglists-meta (nil nil)}}, :name cljs.core/replace, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([smap] [smap coll]), :arglists ([smap] [smap coll]), :arglists-meta (nil nil)}, :method-params ([smap] [smap coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8040, :end-line 8040, :max-fixed-arity 2, :fn-var true, :arglists ([smap] [smap coll]), :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided."}, ->Subvec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4974, :column 10, :end-line 4974, :end-column 16, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta v start end __hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->Subvec, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([meta v start end __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 4974, :end-line 4974, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta v start end __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, associative? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1855, :column 16, :end-line 1855, :end-column 28, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll implements Associative"}, :name cljs.core/associative?, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1855, :ret-tag boolean, :end-line 1855, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements Associative"}, unchecked-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2411, :column 7, :end-line 2411, :end-column 20, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, :name cljs.core/unchecked-int, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2411, :end-line 2411, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, js-keys {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1902, :column 7, :end-line 1902, :end-column 14, :arglists (quote ([obj])), :doc "Return the JavaScript keys for an object."}, :name cljs.core/js-keys, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1902, :end-line 1902, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj])), :doc "Return the JavaScript keys for an object."}, ES6EntriesIterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6EntriesIterator, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 5568, :record false, :end-line 5568, :skip-protocol-flag nil}, keyword? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2903, :column 16, :end-line 2903, :end-column 24, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a Keyword"}, :name cljs.core/keyword?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2903, :ret-tag boolean, :end-line 2903, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a Keyword"}, array-iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3482, :column 7, :end-line 3482, :end-column 17, :arglists (quote ([x]))}, :name cljs.core/array-iter, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3482, :end-line 3482, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, force {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8989, :column 7, :end-line 8989, :end-column 12, :arglists (quote ([x])), :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"}, :name cljs.core/force, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8989, :end-line 8989, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"}, group-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9198, :column 7, :end-line 9198, :end-column 15, :arglists (quote ([f coll])), :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll."}, :name cljs.core/group-by, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9198, :end-line 9198, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f coll])), :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll."}, -rseq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 576, :column 9, :end-line 576, :end-column 14, :tag clj, :protocol cljs.core/IReversible, :doc "Returns a seq of the items in coll in reversed order.", :arglists (quote ([coll]))}, :protocol cljs.core/IReversible, :name cljs.core/-rseq, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 574, :ret-tag clj, :end-line 576, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reversed order."}, prn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8751, :column 7, :end-line 8751, :end-column 10, :arglists (quote ([& objs])), :doc "Same as pr followed by (newline).", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/prn, :variadic true, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8751, :end-line 8751, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "Same as pr followed by (newline)."}, tv-pop-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5127, :column 8, :end-line 5127, :end-column 19, :private true, :arglists (quote ([tv level node]))}, :private true, :name cljs.core/tv-pop-tail, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([tv level node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5127, :end-line 5127, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tv level node]))}, default-dispatch-val {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9606, :column 7, :end-line 9606, :end-column 27, :arglists (quote ([multifn])), :doc "Given a multimethod, return it's default-dispatch-val."}, :name cljs.core/default-dispatch-val, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9606, :end-line 9606, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, return it's default-dispatch-val."}, ->Atom {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3883, :column 10, :end-line 3883, :end-column 14, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}, :factory :positional, :arglists (quote ([state meta validator watches]))}, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/->Atom, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([state meta validator watches]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3883, :end-line 3883, :max-fixed-arity 4, :fn-var true, :arglists (quote ([state meta validator watches])), :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}}, PersistentHashMap {:meta {:file "cljs/core.cljs", :line 5997, :column 27, :end-line 5997, :end-column 44, :declared true}, :num-fields 6, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/PersistentHashMap, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 6622, :record false, :declared true, :end-line 6622, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, unchecked-multiply {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2362, :column 15, :end-line 2362, :end-column 33, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/unchecked-multiply, :variadic true, :file "cljs/core.cljs", :end-column 33, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 2362, :ret-tag number, :end-line 2362, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the product of nums. (*) returns 1."}, ArrayNodeSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ArrayNodeSeq, :file "cljs/core.cljs", :end-column 22, :type true, :column 10, :line 6567, :record false, :end-line 6567, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, even? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3715, :column 16, :end-line 3715, :end-column 21, :tag boolean, :arglists (quote ([n])), :doc "Returns true if n is even, throws an exception if n is not an integer"}, :name cljs.core/even?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3715, :ret-tag boolean, :end-line 3715, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is even, throws an exception if n is not an integer"}, es6-iterator-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1123, :column 7, :end-line 1123, :end-column 23, :arglists (quote ([iter])), :doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq."}, :name cljs.core/es6-iterator-seq, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1123, :end-line 1123, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iter])), :doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq."}, unchecked-dec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2339, :column 7, :end-line 2339, :end-column 20, :arglists (quote ([x])), :doc "Returns a number one less than x, an int."}, :name cljs.core/unchecked-dec, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2339, :end-line 2339, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one less than x, an int."}, hash-collision-node-find-index {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6379, :column 8, :end-line 6379, :end-column 38, :private true, :arglists (quote ([arr cnt key]))}, :private true, :name cljs.core/hash-collision-node-find-index, :variadic false, :file "cljs/core.cljs", :end-column 38, :method-params ([arr cnt key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6379, :end-line 6379, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr cnt key]))}, persistent-array-map-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5729, :column 7, :end-line 5729, :end-column 31, :arglists (quote ([arr i _meta]))}, :name cljs.core/persistent-array-map-seq, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([arr i _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5729, :end-line 5729, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i _meta]))}, RangeIterator {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/RangeIterator, :file "cljs/core.cljs", :end-column 23, :type true, :column 10, :line 8222, :record false, :end-line 8222, :skip-protocol-flag nil}, MultiStepper {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/MultiStepper, :file "cljs/core.cljs", :end-column 22, :type true, :column 10, :line 3552, :record false, :end-line 3552, :skip-protocol-flag nil}, tagged-literal? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9783, :column 7, :end-line 9783, :end-column 22, :arglists (quote ([value])), :doc "Return true if the value is the data representation of a tagged literal"}, :name cljs.core/tagged-literal?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9783, :end-line 9783, :max-fixed-arity 1, :fn-var true, :arglists (quote ([value])), :doc "Return true if the value is the data representation of a tagged literal"}, double-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3210, :column 7, :end-line 3210, :end-column 19, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}}, :name cljs.core/double-array, :variadic false, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3210, :end-line 3210, :max-fixed-arity 2, :fn-var true, :arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure."}, create-ns {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9922, :column 7, :end-line 9922, :end-column 16, :arglists (quote ([sym] [sym ns-obj])), :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([sym] [sym ns-obj]), :arglists ([sym] [sym ns-obj]), :arglists-meta (nil nil)}}, :name cljs.core/create-ns, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([sym] [sym ns-obj]), :arglists ([sym] [sym ns-obj]), :arglists-meta (nil nil)}, :method-params ([sym] [sym ns-obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9922, :end-line 9922, :max-fixed-arity 2, :fn-var true, :arglists ([sym] [sym ns-obj])}, ->EmptyList {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2707, :column 10, :end-line 2707, :end-column 19, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta]))}, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->EmptyList, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 2707, :end-line 2707, :max-fixed-arity 1, :fn-var true, :arglists (quote ([meta])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, seq-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2097, :column 8, :end-line 2097, :end-column 18, :private true, :arglists (quote ([f coll] [f val coll])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f val coll]), :arglists ([f coll] [f val coll]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/seq-reduce, :variadic false, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f val coll]), :arglists ([f coll] [f val coll]), :arglists-meta (nil nil)}, :method-params ([f coll] [f val coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2097, :end-line 2097, :max-fixed-arity 3, :fn-var true, :arglists ([f coll] [f val coll])}, spread {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3262, :column 7, :end-line 3262, :end-column 13, :arglists (quote ([arglist]))}, :name cljs.core/spread, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([arglist]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3262, :end-line 3262, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arglist]))}, balance-left {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6941, :column 8, :end-line 6941, :end-column 20, :private true, :arglists (quote ([key val ins right]))}, :private true, :name cljs.core/balance-left, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([key val ins right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6941, :end-line 6941, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val ins right]))}, rseq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2768, :column 12, :end-line 2768, :end-column 16, :tag seq, :arglists (quote ([coll])), :doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil"}, :name cljs.core/rseq, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2768, :ret-tag seq, :end-line 2768, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil"}, ex-cause {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9722, :column 7, :end-line 9722, :end-column 15, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns exception cause (an Error / ExceptionInfo) if ex is an\n  ExceptionInfo.\n  Otherwise returns nil."}, :name cljs.core/ex-cause, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9722, :end-line 9722, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns exception cause (an Error / ExceptionInfo) if ex is an\n  ExceptionInfo.\n  Otherwise returns nil."}, IReset {:meta {:file "cljs/core.cljs", :line 695, :column 14, :end-line 695, :end-column 20, :doc "Protocol for adding resetting functionality.", :protocol-symbol true, :protocol-info {:methods {-reset! [[o new-value]]}}}, :protocol-symbol true, :name cljs.core/IReset, :file "cljs/core.cljs", :end-column 20, :column 1, :line 695, :protocol-info {:methods {-reset! [[o new-value]]}}, :info nil, :end-line 695, :impls #{}, :doc "Protocol for adding resetting functionality."}, IEmptyableCollection {:meta {:file "cljs/core.cljs", :line 425, :column 14, :end-line 425, :end-column 34, :doc "Protocol for creating an empty collection.", :protocol-symbol true, :protocol-info {:methods {-empty [[coll]]}}}, :protocol-symbol true, :name cljs.core/IEmptyableCollection, :file "cljs/core.cljs", :end-column 34, :column 1, :line 425, :protocol-info {:methods {-empty [[coll]]}}, :info nil, :end-line 425, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for creating an empty collection."}, array-map-index-of {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5655, :column 8, :end-line 5655, :end-column 26, :private true, :arglists (quote ([m k]))}, :private true, :name cljs.core/array-map-index-of, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5655, :end-line 5655, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m k]))}, ex-message {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9714, :column 7, :end-line 9714, :end-column 17, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns the message attached to the given Error / ExceptionInfo object.\n  For non-Errors returns nil."}, :name cljs.core/ex-message, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9714, :end-line 9714, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns the message attached to the given Error / ExceptionInfo object.\n  For non-Errors returns nil."}, string-print {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8563, :column 7, :end-line 8563, :end-column 19, :arglists (quote ([x]))}, :name cljs.core/string-print, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8563, :end-line 8563, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, float {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2316, :column 15, :end-line 2316, :end-column 20, :tag number, :arglists (quote ([x]))}, :name cljs.core/float, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2316, :ret-tag number, :end-line 2316, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, fixture2 {:name cljs.core/fixture2, :file "cljs/core.cljs", :line 8969, :column 1, :end-line 8969, :end-column 14, :meta {:file "cljs/core.cljs", :line 8969, :column 6, :end-line 8969, :end-column 14}}, IRecord {:meta {:file "cljs/core.cljs", :line 571, :column 14, :end-line 571, :end-column 21, :doc "Marker interface indicating a record object", :protocol-symbol true, :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/IRecord, :file "cljs/core.cljs", :end-column 21, :column 1, :line 571, :protocol-info {:methods {}}, :info nil, :end-line 571, :impls #{}, :doc "Marker interface indicating a record object"}, pr-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8709, :column 7, :end-line 8709, :end-column 13, :arglists (quote ([& objs])), :doc "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/pr-str, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8709, :end-line 8709, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter."}, first-array-for-longvec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4598, :column 8, :end-line 4598, :end-column 31, :private true, :arglists (quote ([pv]))}, :private true, :name cljs.core/first-array-for-longvec, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([pv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4598, :end-line 4598, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pv]))}, es6-set-entries-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5590, :column 7, :end-line 5590, :end-column 31, :arglists (quote ([coll]))}, :name cljs.core/es6-set-entries-iterator, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5590, :end-line 5590, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, concat {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3270, :column 7, :end-line 3270, :end-column 13, :arglists (quote ([] [x] [x y] [x y & zs])), :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & zs]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/concat, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & zs]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 3270, :end-line 3270, :max-fixed-arity 2, :fn-var true, :arglists ([] [x] [x y] [x y & zs]), :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls."}, -methods {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9382, :column 4, :end-line 9382, :end-column 12, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-methods, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9376, :end-line 9382, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, js-reserved {:name cljs.core/js-reserved, :file "cljs/core.cljs", :line 9810, :column 1, :end-line 9810, :end-column 17, :meta {:file "cljs/core.cljs", :line 9810, :column 6, :end-line 9810, :end-column 17}}, IDerefWithTimeout {:meta {:file "cljs/core.cljs", :line 522, :column 14, :end-line 522, :end-column 31, :doc nil, :protocol-symbol true, :protocol-info {:methods {-deref-with-timeout [[o msec timeout-val]]}}}, :protocol-symbol true, :name cljs.core/IDerefWithTimeout, :file "cljs/core.cljs", :end-column 31, :column 1, :line 522, :protocol-info {:methods {-deref-with-timeout [[o msec timeout-val]]}}, :info nil, :end-line 522, :impls #{}, :doc nil}, symbol {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 928, :column 7, :end-line 928, :end-column 13, :arglists (quote ([name] [ns name])), :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([name] [ns name]), :arglists ([name] [ns name]), :arglists-meta (nil nil)}}, :name cljs.core/symbol, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([name] [ns name]), :arglists ([name] [ns name]), :arglists-meta (nil nil)}, :method-params ([name] [ns name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 928, :end-line 928, :max-fixed-arity 2, :fn-var true, :arglists ([name] [ns name])}, to-array-2d {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3155, :column 7, :end-line 3155, :end-column 18, :arglists (quote ([coll])), :doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll."}, :name cljs.core/to-array-2d, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3155, :end-line 3155, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll."}, Subvec {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/Subvec, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 4974, :record false, :end-line 4974, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, ExceptionInfo {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9670, :column 3, :end-line 9670, :end-column 16, :jsdoc ["@constructor"], :arglists (quote ([message data cause]))}, :name cljs.core/ExceptionInfo, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([message data cause]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9669, :end-line 9670, :max-fixed-arity 3, :fn-var true, :arglists (quote ([message data cause])), :jsdoc ["@constructor"]}, mod {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2440, :column 7, :end-line 2440, :end-column 10, :arglists (quote ([n d])), :doc "Modulus of num and div. Truncates toward negative infinity."}, :name cljs.core/mod, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2440, :end-line 2440, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "Modulus of num and div. Truncates toward negative infinity."}, ISet {:meta {:file "cljs/core.cljs", :line 497, :column 14, :end-line 497, :end-column 18, :doc "Protocol for adding set functionality to a collection.", :protocol-symbol true, :protocol-info {:methods {-disjoin [[coll v]]}}}, :protocol-symbol true, :name cljs.core/ISet, :file "cljs/core.cljs", :end-column 18, :column 1, :line 497, :protocol-info {:methods {-disjoin [[coll v]]}}, :info nil, :end-line 497, :impls #{cljs.core/PersistentHashSet cljs.core/PersistentTreeSet}, :doc "Protocol for adding set functionality to a collection."}, pop {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1813, :column 7, :end-line 1813, :end-column 10, :arglists (quote ([coll])), :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast."}, :name cljs.core/pop, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1813, :end-line 1813, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast."}, IPending {:meta {:file "cljs/core.cljs", :line 611, :column 14, :end-line 611, :end-column 22, :doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay.", :protocol-symbol true, :protocol-info {:methods {-realized? [[d]]}}}, :protocol-symbol true, :name cljs.core/IPending, :file "cljs/core.cljs", :end-column 22, :column 1, :line 611, :protocol-info {:methods {-realized? [[d]]}}, :info nil, :end-line 611, :impls #{cljs.core/Delay}, :doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay."}, -entry-key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 591, :column 4, :end-line 591, :end-column 14, :protocol cljs.core/ISorted, :doc "Returns the key for entry.", :arglists (quote ([coll entry]))}, :protocol cljs.core/ISorted, :name cljs.core/-entry-key, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll entry]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 579, :end-line 591, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll entry])), :doc "Returns the key for entry."}, CHAR_MAP {:name cljs.core/CHAR_MAP, :file "cljs/core.cljs", :line 258, :column 1, :end-line 259, :end-column 11, :jsdoc ["@enum {string"], :meta {:file "cljs/core.cljs", :line 259, :column 3, :end-line 259, :end-column 11, :jsdoc ["@enum {string"]}}, pop-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4632, :column 8, :end-line 4632, :end-column 16, :private true, :arglists (quote ([pv level node]))}, :private true, :name cljs.core/pop-tail, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([pv level node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4632, :end-line 4632, :max-fixed-arity 3, :fn-var true, :arglists (quote ([pv level node]))}, dissoc! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3345, :column 7, :end-line 3345, :end-column 14, :arglists (quote ([tcoll key] [tcoll key & ks])), :doc "Returns a transient map that doesn't contain a mapping for key(s).", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([tcoll key]), :arglists ([tcoll key] [tcoll key & ks]), :arglists-meta (nil nil)}}, :name cljs.core/dissoc!, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([tcoll key]), :arglists ([tcoll key] [tcoll key & ks]), :arglists-meta (nil nil)}, :method-params ([tcoll key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3345, :end-line 3345, :max-fixed-arity 2, :fn-var true, :arglists ([tcoll key] [tcoll key & ks]), :doc "Returns a transient map that doesn't contain a mapping for key(s)."}, reductions {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8406, :column 7, :end-line 8406, :end-column 17, :arglists (quote ([f coll] [f init coll])), :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f init coll]), :arglists ([f coll] [f init coll]), :arglists-meta (nil nil)}}, :name cljs.core/reductions, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f init coll]), :arglists ([f coll] [f init coll]), :arglists-meta (nil nil)}, :method-params ([f coll] [f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8406, :end-line 8406, :max-fixed-arity 3, :fn-var true, :arglists ([f coll] [f init coll]), :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init."}, indexed? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1324, :column 16, :end-line 1324, :end-column 24, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll implements nth in constant time"}, :name cljs.core/indexed?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1324, :ret-tag boolean, :end-line 1324, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements nth in constant time"}, - {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2216, :column 15, :end-line 2216, :end-column 16, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/-, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2216, :ret-tag number, :end-line 2216, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result."}, -equiv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 552, :column 13, :end-line 552, :end-column 19, :tag boolean, :protocol cljs.core/IEquiv, :doc "Returns true if o and other are equal, false otherwise.", :arglists (quote ([o other]))}, :protocol cljs.core/IEquiv, :name cljs.core/-equiv, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([o other]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 550, :ret-tag boolean, :end-line 552, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([o other])), :doc "Returns true if o and other are equal, false otherwise."}, ->RangeIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8222, :column 10, :end-line 8222, :end-column 23, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([i end step]))}, :protocols #{cljs.core/Object}, :name cljs.core/->RangeIterator, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([i end step]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 8222, :end-line 8222, :max-fixed-arity 3, :fn-var true, :arglists (quote ([i end step])), :skip-protocol-flag nil}, ->ArrayNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6282, :column 10, :end-line 6282, :end-column 19, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([edit cnt arr]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayNode, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([edit cnt arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6282, :end-line 6282, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit cnt arr])), :skip-protocol-flag nil}, assoc! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3333, :column 7, :end-line 3333, :end-column 13, :arglists (quote ([tcoll key val] [tcoll key val & kvs])), :doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([tcoll key val]), :arglists ([tcoll key val] [tcoll key val & kvs]), :arglists-meta (nil nil)}}, :name cljs.core/assoc!, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([tcoll key val]), :arglists ([tcoll key val] [tcoll key val & kvs]), :arglists-meta (nil nil)}, :method-params ([tcoll key val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3333, :end-line 3333, :max-fixed-arity 3, :fn-var true, :arglists ([tcoll key val] [tcoll key val & kvs]), :doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll."}, hash-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8022, :column 7, :end-line 8022, :end-column 15, :arglists (quote ([] [& keys])), :doc "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params ([]), :arglists ([] [& keys]), :arglists-meta (nil nil)}}, :name cljs.core/hash-set, :variadic true, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 0, :method-params ([]), :arglists ([] [& keys]), :arglists-meta (nil nil)}, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8022, :end-line 8022, :max-fixed-arity 0, :fn-var true, :arglists ([] [& keys]), :doc "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj."}, reduce-kv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2163, :column 7, :end-line 2163, :end-column 16, :arglists (quote ([f init coll])), :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals."}, :name cljs.core/reduce-kv, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2163, :end-line 2163, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f init coll])), :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals."}, reset! {:name cljs.core/reset!, :file "cljs/core.cljs", :line 6010, :column 1, :end-line 6010, :end-column 55, :declared true, :meta {:file "cljs/core.cljs", :line 6010, :column 49, :end-line 6010, :end-column 55, :declared true}}, name {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8090, :column 7, :end-line 8090, :end-column 11, :arglists (quote ([x])), :doc "Returns the name String of a string, symbol or keyword."}, :name cljs.core/name, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8090, :end-line 8090, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns the name String of a string, symbol or keyword."}, ->RedNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7146, :column 10, :end-line 7146, :end-column 17, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :factory :positional, :arglists (quote ([key val left right __hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->RedNode, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([key val left right __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7146, :end-line 7146, :max-fixed-arity 5, :fn-var true, :arglists (quote ([key val left right __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, unchecked-array-for {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4606, :column 8, :end-line 4606, :end-column 27, :private true, :arglists (quote ([pv i]))}, :private true, :name cljs.core/unchecked-array-for, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([pv i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4606, :end-line 4606, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pv i]))}, Fn {:meta {:file "cljs/core.cljs", :line 384, :column 14, :end-line 384, :end-column 16, :doc "Marker protocol", :protocol-symbol true, :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/Fn, :file "cljs/core.cljs", :end-column 16, :column 1, :line 384, :protocol-info {:methods {}}, :info nil, :end-line 384, :impls #{cljs.core/Var function cljs.core/MetaFn}, :doc "Marker protocol"}, ffirst {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1487, :column 7, :end-line 1487, :end-column 13, :arglists (quote ([coll])), :doc "Same as (first (first x))"}, :name cljs.core/ffirst, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1487, :end-line 1487, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (first x))"}, sorted-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8028, :column 7, :end-line 8028, :end-column 17, :arglists (quote ([& keys])), :doc "Returns a new sorted set with supplied keys.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keys)], :arglists ([& keys]), :arglists-meta (nil)}}, :name cljs.core/sorted-set, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keys)], :arglists ([& keys]), :arglists-meta (nil)}, :method-params [(keys)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8028, :end-line 8028, :max-fixed-arity 0, :fn-var true, :arglists ([& keys]), :doc "Returns a new sorted set with supplied keys."}, pr-with-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8696, :column 8, :end-line 8696, :end-column 20, :private true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects using string-print, observing all\n  the options given in opts"}, :private true, :name cljs.core/pr-with-opts, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8696, :end-line 8696, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects using string-print, observing all\n  the options given in opts"}, PersistentTreeMap {:num-fields 5, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/PersistentTreeMap, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7396, :record false, :end-line 7396, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, ->PersistentTreeMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7396, :column 10, :end-line 7396, :end-column 27, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :factory :positional, :arglists (quote ([comp tree cnt meta __hash]))}, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->PersistentTreeMap, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([comp tree cnt meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7396, :end-line 7396, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp tree cnt meta __hash])), :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, array-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1287, :column 8, :end-line 1287, :end-column 20, :private true, :arglists (quote ([arr f] [arr f val] [arr f val idx])), :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([arr f] [arr f val] [arr f val idx]), :arglists ([arr f] [arr f val] [arr f val idx]), :arglists-meta (nil nil nil)}}, :private true, :name cljs.core/array-reduce, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([arr f] [arr f val] [arr f val idx]), :arglists ([arr f] [arr f val] [arr f val idx]), :arglists-meta (nil nil nil)}, :method-params ([arr f] [arr f val] [arr f val idx]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1287, :end-line 1287, :max-fixed-arity 4, :fn-var true, :arglists ([arr f] [arr f val] [arr f val idx])}, counted? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1320, :column 16, :end-line 1320, :end-column 24, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll implements count in constant time"}, :name cljs.core/counted?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1320, :ret-tag boolean, :end-line 1320, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements count in constant time"}, tagged-literal {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9788, :column 7, :end-line 9788, :end-column 21, :arglists (quote ([tag form])), :doc "Construct a data representation of a tagged literal from a\n  tag symbol and a form."}, :name cljs.core/tagged-literal, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([tag form]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9788, :end-line 9788, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag form])), :doc "Construct a data representation of a tagged literal from a\n  tag symbol and a form."}, println {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8739, :column 7, :end-line 8739, :end-column 14, :arglists (quote ([& objs])), :doc "Same as print followed by (newline)", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/println, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8739, :end-line 8739, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "Same as print followed by (newline)"}, assoc-in {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4495, :column 7, :end-line 4495, :end-column 15, :arglists (quote ([m [k & ks] v])), :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created."}, :name cljs.core/assoc-in, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([m p__9220 v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4495, :end-line 4495, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m [k & ks] v])), :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created."}, PersistentHashSet {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/PersistentHashSet, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7774, :record false, :end-line 7774, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, bit-test {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2500, :column 16, :end-line 2500, :end-column 24, :tag boolean, :arglists (quote ([x n])), :doc "Test bit at index n"}, :name cljs.core/bit-test, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2500, :ret-tag boolean, :end-line 2500, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x n])), :doc "Test bit at index n"}, ->Namespace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9876, :column 10, :end-line 9876, :end-column 19, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash}, :factory :positional, :arglists (quote ([obj name]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object}, :name cljs.core/->Namespace, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([obj name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 9876, :end-line 9876, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj name])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash}}, TransientHashMap {:meta {:file "cljs/core.cljs", :line 6620, :column 10, :end-line 6620, :end-column 26, :declared true}, :num-fields 5, :protocols #{cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientHashMap, :file "cljs/core.cljs", :end-column 26, :type true, :column 10, :line 6771, :record false, :declared true, :end-line 6771, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, ->PersistentHashMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6622, :column 10, :end-line 6622, :end-column 27, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :factory :positional, :arglists (quote ([meta cnt root has-nil? nil-val __hash]))}, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->PersistentHashMap, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([meta cnt root has-nil? nil-val __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6622, :end-line 6622, :max-fixed-arity 6, :fn-var true, :arglists (quote ([meta cnt root has-nil? nil-val __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, array-extend-kv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5658, :column 8, :end-line 5658, :end-column 23, :private true, :arglists (quote ([arr k v]))}, :private true, :name cljs.core/array-extend-kv, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([arr k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5658, :end-line 5658, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr k v]))}, ISwap {:meta {:file "cljs/core.cljs", :line 700, :column 14, :end-line 700, :end-column 19, :doc "Protocol for adding swapping functionality.", :protocol-symbol true, :protocol-info {:methods {-swap! [[o f] [o f a] [o f a b] [o f a b xs]]}}}, :protocol-symbol true, :name cljs.core/ISwap, :file "cljs/core.cljs", :end-column 19, :column 1, :line 700, :protocol-info {:methods {-swap! [[o f] [o f a] [o f a b] [o f a b xs]]}}, :info nil, :end-line 700, :impls #{}, :doc "Protocol for adding swapping functionality."}, ChunkedCons {:meta {:file "cljs/core.cljs", :line 1887, :column 10, :end-line 1887, :end-column 21, :declared true}, :num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/ChunkedCons, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 3057, :record false, :declared true, :end-line 3057, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}}, memoize {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9150, :column 7, :end-line 9150, :end-column 14, :arglists (quote ([f])), :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use."}, :name cljs.core/memoize, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9150, :end-line 9150, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use."}, alter-meta! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8905, :column 7, :end-line 8905, :end-column 18, :arglists (quote ([iref f & args])), :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(iref f args)], :arglists ([iref f & args]), :arglists-meta (nil)}}, :name cljs.core/alter-meta!, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(iref f args)], :arglists ([iref f & args]), :arglists-meta (nil)}, :method-params [(iref f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8905, :end-line 8905, :max-fixed-arity 2, :fn-var true, :arglists ([iref f & args]), :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects"}, ->StringBufferWriter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 718, :column 10, :end-line 718, :end-column 28, :protocols #{cljs.core/IWriter}, :skip-protocol-flag #{cljs.core/IWriter}, :factory :positional, :arglists (quote ([sb]))}, :protocols #{cljs.core/IWriter}, :name cljs.core/->StringBufferWriter, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([sb]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 718, :end-line 718, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sb])), :skip-protocol-flag #{cljs.core/IWriter}}, zero? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2545, :column 16, :end-line 2545, :end-column 21, :tag boolean, :arglists (quote ([n])), :doc "Returns true if num is zero, else false"}, :name cljs.core/zero?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2545, :ret-tag boolean, :end-line 2545, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if num is zero, else false"}, tv-ensure-editable {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5102, :column 8, :end-line 5102, :end-column 26, :private true, :arglists (quote ([edit node]))}, :private true, :name cljs.core/tv-ensure-editable, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([edit node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5102, :end-line 5102, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit node]))}, *main-cli-fn* {:name cljs.core/*main-cli-fn*, :file "cljs/core.cljs", :line 222, :column 1, :end-line 226, :end-column 16, :doc "When compiled for a command-line target, whatever\n  function *main-fn* is set to will be called with the command-line\n  argv as arguments", :meta {:file "cljs/core.cljs", :line 226, :column 3, :end-line 226, :end-column 16, :doc "When compiled for a command-line target, whatever\n  function *main-fn* is set to will be called with the command-line\n  argv as arguments"}}, -assoc-n {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 514, :column 9, :end-line 514, :end-column 17, :tag clj, :protocol cljs.core/IVector, :doc "Returns a new vector with value val added at position n.", :arglists (quote ([coll n val]))}, :protocol cljs.core/IVector, :name cljs.core/-assoc-n, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll n val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 512, :ret-tag clj, :end-line 514, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll n val])), :doc "Returns a new vector with value val added at position n."}, unchecked-dec-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2344, :column 7, :end-line 2344, :end-column 24, :arglists (quote ([x])), :doc "Returns a number one less than x, an int."}, :name cljs.core/unchecked-dec-int, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2344, :end-line 2344, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one less than x, an int."}, hash-imap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2613, :column 8, :end-line 2613, :end-column 17, :private true, :arglists (quote ([m]))}, :private true, :name cljs.core/hash-imap, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2613, :end-line 2613, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m]))}, dominates {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9347, :column 8, :end-line 9347, :end-column 17, :private true, :arglists (quote ([x y prefer-table]))}, :private true, :name cljs.core/dominates, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x y prefer-table]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9347, :end-line 9347, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x y prefer-table]))}, persistent! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3313, :column 7, :end-line 3313, :end-column 18, :arglists (quote ([tcoll])), :doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception."}, :name cljs.core/persistent!, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3313, :end-line 3313, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tcoll])), :doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception."}, set-print-fn! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 54, :column 7, :end-line 54, :end-column 20, :arglists (quote ([f])), :doc "Set *print-fn* to f."}, :name cljs.core/set-print-fn!, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 54, :end-line 54, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Set *print-fn* to f."}, nnext {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1502, :column 7, :end-line 1502, :end-column 12, :arglists (quote ([coll])), :doc "Same as (next (next x))"}, :name cljs.core/nnext, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1502, :end-line 1502, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (next (next x))"}, Box {:num-fields 1, :protocols #{}, :name cljs.core/Box, :file "cljs/core.cljs", :end-column 13, :type true, :column 10, :line 6008, :record false, :end-line 6008, :skip-protocol-flag nil}, balance-right {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6966, :column 8, :end-line 6966, :end-column 21, :private true, :arglists (quote ([key val left ins]))}, :private true, :name cljs.core/balance-right, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([key val left ins]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6966, :end-line 6966, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val left ins]))}, throw-no-method-error {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9387, :column 8, :end-line 9387, :end-column 29, :private true, :arglists (quote ([name dispatch-val]))}, :private true, :name cljs.core/throw-no-method-error, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([name dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9387, :end-line 9387, :max-fixed-arity 2, :fn-var true, :arglists (quote ([name dispatch-val]))}, demunge-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9853, :column 8, :end-line 9853, :end-column 19, :private true, :arglists (quote ([munged-name]))}, :private true, :name cljs.core/demunge-str, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([munged-name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9853, :end-line 9853, :max-fixed-arity 1, :fn-var true, :arglists (quote ([munged-name]))}, add-watch {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8919, :column 7, :end-line 8919, :end-column 16, :arglists (quote ([iref key f])), :doc "Alpha - subject to change.\n\n  Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom's state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom's value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;=> 1"}, :name cljs.core/add-watch, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([iref key f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8919, :end-line 8919, :max-fixed-arity 3, :fn-var true, :arglists (quote ([iref key f])), :doc "Alpha - subject to change.\n\n  Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom's state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom's value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;=> 1"}, not-every? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3696, :column 16, :end-line 3696, :end-column 26, :tag boolean, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for every x in\n  coll, else true."}, :name cljs.core/not-every?, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3696, :ret-tag boolean, :end-line 3696, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for every x in\n  coll, else true."}, rem {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2451, :column 7, :end-line 2451, :end-column 10, :arglists (quote ([n d])), :doc "remainder of dividing numerator by denominator."}, :name cljs.core/rem, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2451, :end-line 2451, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "remainder of dividing numerator by denominator."}, pr-sb-with-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8672, :column 8, :end-line 8672, :end-column 23, :private true, :arglists (quote ([objs opts]))}, :private true, :name cljs.core/pr-sb-with-opts, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8672, :end-line 8672, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts]))}, BitmapIndexedNode {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/BitmapIndexedNode, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 6071, :record false, :end-line 6071, :skip-protocol-flag nil}, ->NodeSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6504, :column 10, :end-line 6504, :end-column 17, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta nodes i s __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->NodeSeq, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([meta nodes i s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6504, :end-line 6504, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta nodes i s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, some {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3701, :column 7, :end-line 3701, :end-column 11, :arglists (quote ([pred coll])), :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)"}, :name cljs.core/some, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3701, :end-line 3701, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)"}, INamed {:meta {:file "cljs/core.cljs", :line 685, :column 14, :end-line 685, :end-column 20, :doc "Protocol for adding a name.", :protocol-symbol true, :protocol-info {:methods {-name [[x]], -namespace [[x]]}}}, :protocol-symbol true, :name cljs.core/INamed, :file "cljs/core.cljs", :end-column 20, :column 1, :line 685, :protocol-info {:methods {-name [[x]], -namespace [[x]]}}, :info nil, :end-line 685, :impls #{cljs.core/MultiFn cljs.core/Keyword cljs.core/Symbol}, :doc "Protocol for adding a name."}, ->Box {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6008, :column 10, :end-line 6008, :end-column 13, :protocols #{}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([val]))}, :protocols #{}, :name cljs.core/->Box, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6008, :end-line 6008, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :skip-protocol-flag nil}, IReduce {:meta {:file "cljs/core.cljs", :line 535, :column 14, :end-line 535, :end-column 21, :doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce.", :protocol-symbol true, :protocol-info {:methods {-reduce [[coll f] [coll f start]]}}}, :protocol-symbol true, :name cljs.core/IReduce, :file "cljs/core.cljs", :end-column 21, :column 1, :line 535, :protocol-info {:methods {-reduce [[coll f] [coll f start]]}}, :info nil, :end-line 535, :impls #{cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ArrayChunk cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce."}, drop {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4200, :column 7, :end-line 4200, :end-column 11, :arglists (quote ([n] [n coll])), :doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/drop, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4200, :end-line 4200, :max-fixed-arity 2, :fn-var true, :arglists ([n] [n coll]), :doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided."}, js-obj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1894, :column 7, :end-line 1894, :end-column 13, :arglists (quote ([] [& keyvals])), :doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params ([]), :arglists ([] [& keyvals]), :arglists-meta (nil nil)}}, :name cljs.core/js-obj, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 0, :method-params ([]), :arglists ([] [& keyvals]), :arglists-meta (nil nil)}, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1894, :end-line 1894, :max-fixed-arity 0, :fn-var true, :arglists ([] [& keyvals]), :doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values."}, ITransientCollection {:meta {:file "cljs/core.cljs", :line 632, :column 14, :end-line 632, :end-column 34, :doc "Protocol for adding basic functionality to transient collections.", :protocol-symbol true, :protocol-info {:methods {-conj! [[tcoll val]], -persistent! [[tcoll]]}}}, :protocol-symbol true, :name cljs.core/ITransientCollection, :file "cljs/core.cljs", :end-column 34, :column 1, :line 632, :protocol-info {:methods {-conj! [[tcoll val]], -persistent! [[tcoll]]}}, :info nil, :end-line 632, :impls #{cljs.core/TransientVector cljs.core/TransientHashMap cljs.core/TransientArrayMap cljs.core/TransientHashSet}, :doc "Protocol for adding basic functionality to transient collections."}, Atom {:num-fields 4, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/Atom, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 3883, :record false, :end-line 3883, :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}}, nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1587, :column 7, :end-line 1587, :end-column 10, :arglists (quote ([coll n] [coll n not-found])), :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}}, :name cljs.core/nth, :variadic false, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1587, :end-line 1587, :max-fixed-arity 3, :fn-var true, :arglists ([coll n] [coll n not-found]), :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences."}, sorted? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1863, :column 16, :end-line 1863, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISorted"}, :name cljs.core/sorted?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1863, :ret-tag boolean, :end-line 1863, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISorted"}, nil? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 165, :column 16, :end-line 165, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is nil, false otherwise."}, :name cljs.core/nil?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 165, :ret-tag boolean, :end-line 165, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is nil, false otherwise."}, split-at {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4268, :column 7, :end-line 4268, :end-column 15, :arglists (quote ([n coll])), :doc "Returns a vector of [(take n coll) (drop n coll)]"}, :name cljs.core/split-at, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4268, :end-line 4268, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "Returns a vector of [(take n coll) (drop n coll)]"}, TransientHashSet {:meta {:file "cljs/core.cljs", :line 7772, :column 10, :end-line 7772, :end-column 26, :declared true}, :num-fields 1, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name cljs.core/TransientHashSet, :file "cljs/core.cljs", :end-column 26, :type true, :column 10, :line 7869, :record false, :declared true, :end-line 7869, :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}}, *e {:name cljs.core/*e, :file "cljs/core.cljs", :line 147, :column 1, :end-line 149, :end-column 5, :doc "bound in a repl thread to the most recent exception caught by the repl", :meta {:file "cljs/core.cljs", :line 149, :column 3, :end-line 149, :end-column 5, :doc "bound in a repl thread to the most recent exception caught by the repl"}}, array-map-extend-kv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5669, :column 8, :end-line 5669, :end-column 27, :private true, :arglists (quote ([m k v]))}, :private true, :name cljs.core/array-map-extend-kv, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([m k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5669, :end-line 5669, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m k v]))}, prn-str-with-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8687, :column 7, :end-line 8687, :end-column 24, :arglists (quote ([objs opts])), :doc "Same as pr-str-with-opts followed by (newline)"}, :name cljs.core/prn-str-with-opts, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8687, :end-line 8687, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Same as pr-str-with-opts followed by (newline)"}, not-native {:name cljs.core/not-native, :file "cljs/core.cljs", :line 156, :column 1, :end-line 156, :end-column 16, :meta {:file "cljs/core.cljs", :line 156, :column 6, :end-line 156, :end-column 16}}, random-sample {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9039, :column 7, :end-line 9039, :end-column 20, :arglists (quote ([prob] [prob coll])), :doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([prob] [prob coll]), :arglists ([prob] [prob coll]), :arglists-meta (nil nil)}}, :name cljs.core/random-sample, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([prob] [prob coll]), :arglists ([prob] [prob coll]), :arglists-meta (nil nil)}, :method-params ([prob] [prob coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9039, :end-line 9039, :max-fixed-arity 2, :fn-var true, :arglists ([prob] [prob coll]), :doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided."}, select-keys {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7756, :column 7, :end-line 7756, :end-column 18, :arglists (quote ([map keyseq])), :doc "Returns a map containing only those entries in map whose key is in keys"}, :name cljs.core/select-keys, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([map keyseq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7756, :end-line 7756, :max-fixed-arity 2, :fn-var true, :arglists (quote ([map keyseq])), :doc "Returns a map containing only those entries in map whose key is in keys"}, bit-and {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2463, :column 7, :end-line 2463, :end-column 14, :arglists (quote ([x y] [x y & more])), :doc "Bitwise and", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}}, :name cljs.core/bit-and, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2463, :end-line 2463, :max-fixed-arity 2, :fn-var true, :arglists ([x y] [x y & more]), :doc "Bitwise and"}, bounded-count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3254, :column 8, :end-line 3254, :end-column 21, :private true, :arglists (quote ([s n]))}, :private true, :name cljs.core/bounded-count, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([s n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3254, :end-line 3254, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s n]))}, update {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4531, :column 7, :end-line 4531, :end-column 13, :arglists (quote ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more])), :doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([m k f] [m k f x] [m k f x y] [m k f x y z]), :arglists ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/update, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([m k f] [m k f x] [m k f x y] [m k f x y z]), :arglists ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]), :arglists-meta (nil nil nil nil nil)}, :method-params ([m k f] [m k f x] [m k f x y] [m k f x y z]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 4531, :end-line 4531, :max-fixed-arity 6, :fn-var true, :arglists ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]), :doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value."}, gensym_counter {:name cljs.core/gensym_counter, :file "cljs/core.cljs", :line 8954, :column 1, :end-line 8954, :end-column 20, :meta {:file "cljs/core.cljs", :line 8954, :column 6, :end-line 8954, :end-column 20}}, find-macros-ns {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9932, :column 7, :end-line 9932, :end-column 21, :arglists (quote ([ns]))}, :name cljs.core/find-macros-ns, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([ns]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9932, :end-line 9932, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ns]))}, list* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3295, :column 7, :end-line 3295, :end-column 12, :arglists (quote ([args] [a args] [a b args] [a b c args] [a b c d & more])), :doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([args] [a args] [a b args] [a b c args]), :arglists ([args] [a args] [a b args] [a b c args] [a b c d & more]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/list*, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([args] [a args] [a b args] [a b c args]), :arglists ([args] [a args] [a b args] [a b c args] [a b c d & more]), :arglists-meta (nil nil nil nil nil)}, :method-params ([args] [a args] [a b args] [a b c args]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 3295, :end-line 3295, :max-fixed-arity 4, :fn-var true, :arglists ([args] [a args] [a b args] [a b c args] [a b c d & more]), :doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence."}, array-index-of-keyword? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5603, :column 8, :end-line 5603, :end-column 31, :private true, :arglists (quote ([arr k]))}, :private true, :name cljs.core/array-index-of-keyword?, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5603, :end-line 5603, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, ->Keyword {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2875, :column 10, :end-line 2875, :end-column 17, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}, :factory :positional, :arglists (quote ([ns name fqn _hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :name cljs.core/->Keyword, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([ns name fqn _hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 2875, :end-line 2875, :max-fixed-arity 4, :fn-var true, :arglists (quote ([ns name fqn _hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}}, update-in {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4504, :column 7, :end-line 4504, :end-column 16, :arglists (quote ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args])), :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c]), :arglists ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/update-in, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c]), :arglists ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args]), :arglists-meta (nil nil nil nil nil)}, :method-params ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 4504, :end-line 4504, :max-fixed-arity 6, :fn-var true, :arglists ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args]), :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created."}, prefer-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9587, :column 7, :end-line 9587, :end-column 20, :arglists (quote ([multifn dispatch-val-x dispatch-val-y])), :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict"}, :name cljs.core/prefer-method, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([multifn dispatch-val-x dispatch-val-y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9587, :end-line 9587, :max-fixed-arity 3, :fn-var true, :arglists (quote ([multifn dispatch-val-x dispatch-val-y])), :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict"}, hash-symbol {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 875, :column 8, :end-line 875, :end-column 19, :private true, :arglists (quote ([sym]))}, :private true, :name cljs.core/hash-symbol, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 875, :end-line 875, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym]))}, ensure-reduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1234, :column 7, :end-line 1234, :end-column 21, :arglists (quote ([x])), :doc "If x is already reduced?, returns it, else returns (reduced x)"}, :name cljs.core/ensure-reduced, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1234, :end-line 1234, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is already reduced?, returns it, else returns (reduced x)"}, edit-and-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6042, :column 8, :end-line 6042, :end-column 20, :private true, :arglists (quote ([inode edit i a] [inode edit i a j b])), :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([inode edit i a] [inode edit i a j b]), :arglists ([inode edit i a] [inode edit i a j b]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/edit-and-set, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([inode edit i a] [inode edit i a j b]), :arglists ([inode edit i a] [inode edit i a j b]), :arglists-meta (nil nil)}, :method-params ([inode edit i a] [inode edit i a j b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6042, :end-line 6042, :max-fixed-arity 6, :fn-var true, :arglists ([inode edit i a] [inode edit i a j b])}, ->PersistentArrayMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5744, :column 10, :end-line 5744, :end-column 28, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta cnt arr __hash]))}, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->PersistentArrayMap, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([meta cnt arr __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5744, :end-line 5744, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta cnt arr __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}}, instance? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 864, :column 16, :end-line 864, :end-column 25, :tag boolean, :arglists (quote ([t o])), :doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false"}, :name cljs.core/instance?, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([t o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 864, :ret-tag boolean, :end-line 864, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([t o])), :doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false"}, mix-collection-hash {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1133, :column 15, :end-line 1133, :end-column 34, :tag number, :arglists (quote ([hash-basis count])), :doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms."}, :name cljs.core/mix-collection-hash, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([hash-basis count]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1133, :ret-tag number, :end-line 1133, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([hash-basis count])), :doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms."}, re-find {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8502, :column 7, :end-line 8502, :end-column 14, :arglists (quote ([re s])), :doc "Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups."}, :name cljs.core/re-find, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8502, :end-line 8502, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups."}, run! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9072, :column 7, :end-line 9072, :end-column 11, :arglists (quote ([proc coll])), :doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil"}, :name cljs.core/run!, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([proc coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9072, :end-line 9072, :max-fixed-arity 2, :fn-var true, :arglists (quote ([proc coll])), :doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil"}, char-escapes {:name cljs.core/char-escapes, :file "cljs/core.cljs", :line 8570, :column 1, :end-line 8570, :end-column 28, :private true, :meta {:file "cljs/core.cljs", :line 8570, :column 16, :end-line 8570, :end-column 28, :private true}}, ES6Iterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6Iterator, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 1097, :record false, :end-line 1097, :skip-protocol-flag nil}, val {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7727, :column 7, :end-line 7727, :end-column 10, :arglists (quote ([map-entry])), :doc "Returns the value in the map entry."}, :name cljs.core/val, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([map-entry]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7727, :end-line 7727, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-entry])), :doc "Returns the value in the map entry."}, unchecked-add {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2325, :column 15, :end-line 2325, :end-column 28, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/unchecked-add, :variadic true, :file "cljs/core.cljs", :end-column 28, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 2325, :ret-tag number, :end-line 2325, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the sum of nums. (+) returns 0."}, not {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 182, :column 16, :end-line 182, :end-column 19, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is logical false, false otherwise."}, :name cljs.core/not, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 182, :ret-tag boolean, :end-line 182, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is logical false, false otherwise."}, -vreset! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 707, :column 4, :end-line 707, :end-column 12, :protocol cljs.core/IVolatile, :doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value.", :arglists (quote ([o new-value]))}, :protocol cljs.core/IVolatile, :name cljs.core/-vreset!, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([o new-value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 705, :end-line 707, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o new-value])), :doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value."}, fn->comparator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2056, :column 17, :end-line 2056, :end-column 31, :private true, :arglists (quote ([f])), :doc "Given a fn that might be boolean valued or a comparator,\n   return a fn that is a comparator."}, :private true, :name cljs.core/fn->comparator, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2056, :end-line 2056, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Given a fn that might be boolean valued or a comparator,\n   return a fn that is a comparator."}, with-meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1790, :column 7, :end-line 1790, :end-column 16, :arglists (quote ([o meta])), :doc "Returns an object of the same type and value as obj, with\n  map m as its metadata."}, :name cljs.core/with-meta, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([o meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1790, :end-line 1790, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o meta])), :doc "Returns an object of the same type and value as obj, with\n  map m as its metadata."}, unreduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1239, :column 7, :end-line 1239, :end-column 16, :arglists (quote ([x])), :doc "If x is reduced?, returns (deref x), else returns x"}, :name cljs.core/unreduced, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1239, :end-line 1239, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is reduced?, returns (deref x), else returns x"}, record? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1878, :column 16, :end-line 1878, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies IRecord"}, :name cljs.core/record?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1878, :ret-tag boolean, :end-line 1878, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IRecord"}, type {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 228, :column 7, :end-line 228, :end-column 11, :arglists (quote ([x])), :doc "Return x's constructor."}, :name cljs.core/type, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 228, :end-line 228, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return x's constructor."}, identical? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 160, :column 16, :end-line 160, :end-column 26, :tag boolean, :arglists (quote ([x y])), :doc "Tests if 2 arguments are the same object"}, :name cljs.core/identical?, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 160, :ret-tag boolean, :end-line 160, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x y])), :doc "Tests if 2 arguments are the same object"}, -namespace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 689, :column 12, :end-line 689, :end-column 22, :tag string, :protocol cljs.core/INamed, :doc "Returns the namespace String of x.", :arglists (quote ([x]))}, :protocol cljs.core/INamed, :name cljs.core/-namespace, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 685, :ret-tag string, :end-line 689, :max-fixed-arity 1, :tag string, :fn-var true, :arglists (quote ([x])), :doc "Returns the namespace String of x."}, unchecked-divide-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2349, :column 15, :end-line 2349, :end-column 35, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/unchecked-divide-int, :variadic true, :file "cljs/core.cljs", :end-column 35, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2349, :ret-tag number, :end-line 2349, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators."}, ns-name {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9939, :column 7, :end-line 9939, :end-column 14, :arglists (quote ([ns-obj]))}, :name cljs.core/ns-name, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([ns-obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9939, :end-line 9939, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ns-obj]))}, swap-global-hierarchy! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9221, :column 8, :end-line 9221, :end-column 30, :private true, :arglists (quote ([f & args])), :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}}, :private true, :name cljs.core/swap-global-hierarchy!, :variadic true, :file "cljs/core.cljs", :end-column 30, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}, :method-params [(f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9221, :end-line 9221, :max-fixed-arity 1, :fn-var true, :arglists ([f & args])}, max-key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8111, :column 7, :end-line 8111, :end-column 14, :arglists (quote ([k x] [k x y] [k x y & more])), :doc "Returns the x for which (k x), a number, is greatest.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([k x] [k x y]), :arglists ([k x] [k x y] [k x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/max-key, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([k x] [k x y]), :arglists ([k x] [k x y] [k x y & more]), :arglists-meta (nil nil nil)}, :method-params ([k x] [k x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 8111, :end-line 8111, :max-fixed-arity 3, :fn-var true, :arglists ([k x] [k x y] [k x y & more]), :doc "Returns the x for which (k x), a number, is greatest."}, ->PersistentTreeSet {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7906, :column 10, :end-line 7906, :end-column 27, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :factory :positional, :arglists (quote ([meta tree-map __hash]))}, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/->PersistentTreeSet, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([meta tree-map __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7906, :end-line 7906, :max-fixed-arity 3, :fn-var true, :arglists (quote ([meta tree-map __hash])), :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, *out* {:name cljs.core/*out*, :file "cljs/core.cljs", :line 34, :column 1, :end-line 36, :end-column 8, :dynamic true, :meta {:file "cljs/core.cljs", :line 36, :column 3, :end-line 36, :end-column 8, :dynamic true}}, ->ChunkBuffer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3008, :column 10, :end-line 3008, :end-column 21, :protocols #{cljs.core/Object cljs.core/ICounted}, :skip-protocol-flag #{cljs.core/ICounted}, :factory :positional, :arglists (quote ([buf end]))}, :protocols #{cljs.core/Object cljs.core/ICounted}, :name cljs.core/->ChunkBuffer, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([buf end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3008, :end-line 3008, :max-fixed-arity 2, :fn-var true, :arglists (quote ([buf end])), :skip-protocol-flag #{cljs.core/ICounted}}, hash-string {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 822, :column 7, :end-line 822, :end-column 18, :arglists (quote ([k]))}, :name cljs.core/hash-string, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 822, :end-line 822, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, ValSeq {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ValSeq, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 7664, :record false, :end-line 7664, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -prefers {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9383, :column 4, :end-line 9383, :end-column 12, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-prefers, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9376, :end-line 9383, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, set-validator! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3977, :column 7, :end-line 3977, :end-column 21, :arglists (quote ([iref val])), :doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed."}, :name cljs.core/set-validator!, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([iref val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3977, :end-line 3977, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref val])), :doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed."}, -meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 527, :column 16, :end-line 527, :end-column 21, :tag clj-or-nil, :protocol cljs.core/IMeta, :doc "Returns the metadata of object o.", :arglists (quote ([o]))}, :protocol cljs.core/IMeta, :name cljs.core/-meta, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 525, :ret-tag clj-or-nil, :end-line 527, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([o])), :doc "Returns the metadata of object o."}, RedNode {:meta {:file "cljs/core.cljs", :line 6939, :column 10, :end-line 6939, :end-column 17, :declared true}, :num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/RedNode, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 7146, :record false, :declared true, :end-line 7146, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, -dispatch-fn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9385, :column 4, :end-line 9385, :end-column 16, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-dispatch-fn, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9376, :end-line 9385, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, ->IndexedSeqIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1328, :column 10, :end-line 1328, :end-column 28, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([arr i]))}, :protocols #{cljs.core/Object}, :name cljs.core/->IndexedSeqIterator, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1328, :end-line 1328, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag nil}, -add-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9378, :column 4, :end-line 9378, :end-column 15, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf dispatch-val method]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-add-method, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([mf dispatch-val method]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9376, :end-line 9378, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf dispatch-val method])), :doc nil}, balance-left-del {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6988, :column 8, :end-line 6988, :end-column 24, :private true, :arglists (quote ([key val del right]))}, :private true, :name cljs.core/balance-left-del, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([key val del right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6988, :end-line 6988, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val del right]))}, swap! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3946, :column 7, :end-line 3946, :end-column 12, :arglists (quote ([a f] [a f x] [a f x y] [a f x y & more])), :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([a f] [a f x] [a f x y]), :arglists ([a f] [a f x] [a f x y] [a f x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/swap!, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([a f] [a f x] [a f x y]), :arglists ([a f] [a f x] [a f x y] [a f x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([a f] [a f x] [a f x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 3946, :end-line 3946, :max-fixed-arity 4, :fn-var true, :arglists ([a f] [a f x] [a f x y] [a f x y & more]), :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in."}, vals {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7721, :column 7, :end-line 7721, :end-column 11, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's values."}, :name cljs.core/vals, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([hash-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7721, :end-line 7721, :max-fixed-arity 1, :fn-var true, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's values."}, -chunked-next {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 682, :column 4, :end-line 682, :end-column 17, :protocol cljs.core/IChunkedNext, :doc "Returns a new collection of coll without the first chunk.", :arglists (quote ([coll]))}, :protocol cljs.core/IChunkedNext, :name cljs.core/-chunked-next, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 680, :end-line 682, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new collection of coll without the first chunk."}, unchecked-subtract {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2387, :column 15, :end-line 2387, :end-column 33, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/unchecked-subtract, :variadic true, :file "cljs/core.cljs", :end-column 33, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2387, :ret-tag number, :end-line 2387, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result."}, remove-pair {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6030, :column 8, :end-line 6030, :end-column 19, :private true, :arglists (quote ([arr i]))}, :private true, :name cljs.core/remove-pair, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6030, :end-line 6030, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i]))}, IMap {:meta {:file "cljs/core.cljs", :line 484, :column 14, :end-line 484, :end-column 18, :doc "Protocol for adding mapping functionality to collections.", :protocol-symbol true, :protocol-info {:methods {-dissoc [[coll k]]}}}, :protocol-symbol true, :name cljs.core/IMap, :file "cljs/core.cljs", :end-column 18, :column 1, :line 484, :protocol-info {:methods {-dissoc [[coll k]]}}, :info nil, :end-line 484, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/PersistentTreeMap}, :doc "Protocol for adding mapping functionality to collections."}, ->SeqIter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3488, :column 10, :end-line 3488, :end-column 17, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([_seq _next]))}, :protocols #{cljs.core/Object}, :name cljs.core/->SeqIter, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([_seq _next]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3488, :end-line 3488, :max-fixed-arity 2, :fn-var true, :arglists (quote ([_seq _next])), :skip-protocol-flag nil}, sorted-set-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8033, :column 7, :end-line 8033, :end-column 20, :arglists (quote ([comparator & keys])), :doc "Returns a new sorted set with supplied keys, using the supplied comparator.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keys)], :arglists ([comparator & keys]), :arglists-meta (nil)}}, :name cljs.core/sorted-set-by, :variadic true, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keys)], :arglists ([comparator & keys]), :arglists-meta (nil)}, :method-params [(comparator keys)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8033, :end-line 8033, :max-fixed-arity 1, :fn-var true, :arglists ([comparator & keys]), :doc "Returns a new sorted set with supplied keys, using the supplied comparator."}, PersistentVector {:num-fields 6, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/PersistentVector, :file "cljs/core.cljs", :end-column 26, :type true, :column 10, :line 4668, :record false, :end-line 4668, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, cloneable? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1017, :column 7, :end-line 1017, :end-column 17, :arglists (quote ([value])), :doc "Return true if x implements ICloneable protocol."}, :name cljs.core/cloneable?, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1017, :end-line 1017, :max-fixed-arity 1, :fn-var true, :arglists (quote ([value])), :doc "Return true if x implements ICloneable protocol."}, hash-string* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 805, :column 7, :end-line 805, :end-column 19, :arglists (quote ([s]))}, :name cljs.core/hash-string*, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 805, :end-line 805, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, key-test {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6012, :column 16, :end-line 6012, :end-column 24, :tag boolean, :arglists (quote ([key other]))}, :name cljs.core/key-test, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([key other]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6012, :ret-tag boolean, :end-line 6012, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([key other]))}, ->LazyTransformer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3597, :column 10, :end-line 3597, :end-column 25, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([stepper first rest meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->LazyTransformer, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([stepper first rest meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3597, :end-line 3597, :max-fixed-arity 4, :fn-var true, :arglists (quote ([stepper first rest meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}}, -reset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9377, :column 4, :end-line 9377, :end-column 10, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-reset, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9376, :end-line 9377, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, true? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1938, :column 16, :end-line 1938, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is the value true, false otherwise."}, :name cljs.core/true?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1938, :ret-tag boolean, :end-line 1938, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is the value true, false otherwise."}, array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 333, :column 14, :end-line 333, :end-column 19, :tag array, :arglists (quote ([var-args])), :doc "Creates a new javascript array.\n@param {...*} var_args"}, :name cljs.core/array, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([var-args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 333, :ret-tag array, :end-line 333, :max-fixed-arity 1, :tag array, :fn-var true, :arglists (quote ([var-args])), :doc "Creates a new javascript array.\n@param {...*} var_args"}, print {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8730, :column 3, :end-line 8730, :end-column 8, :doc "Prints the object(s) using string-print.\n  print and println produce output for human consumption."}, :name cljs.core/print, :variadic true, :file "cljs/core.cljs", :end-column 8, :method-params ([objs]), :protocol-impl nil, :arglists-meta (), :column 1, :line 8727, :end-line 8730, :max-fixed-arity 0, :fn-var true, :arglists nil, :doc "Prints the object(s) using string-print.\n  print and println produce output for human consumption."}, -peek {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 506, :column 4, :end-line 506, :end-column 9, :protocol cljs.core/IStack, :doc "Returns the item from the top of the stack. Is used by cljs.core/peek.", :arglists (quote ([coll]))}, :protocol cljs.core/IStack, :name cljs.core/-peek, :variadic false, :file "cljs/core.cljs", :end-column 9, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 502, :end-line 506, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the item from the top of the stack. Is used by cljs.core/peek."}, ISeq {:meta {:file "cljs/core.cljs", :line 451, :column 14, :end-line 451, :end-column 18, :doc "Protocol for collections to provide access to their items as sequences.", :protocol-symbol true, :protocol-info {:methods {-first [[coll]], -rest [[coll]]}}}, :protocol-symbol true, :name cljs.core/ISeq, :file "cljs/core.cljs", :end-column 18, :column 1, :line 451, :protocol-info {:methods {-first [[coll]], -rest [[coll]]}}, :info nil, :end-line 451, :impls #{cljs.core/Cons cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/LazySeq cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq}, :doc "Protocol for collections to provide access to their items as sequences."}, empty {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1534, :column 7, :end-line 1534, :end-column 12, :arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll, or nil"}, :name cljs.core/empty, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1534, :end-line 1534, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll, or nil"}, remove-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9582, :column 7, :end-line 9582, :end-column 20, :arglists (quote ([multifn dispatch-val])), :doc "Removes the method of multimethod associated with dispatch-value."}, :name cljs.core/remove-method, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([multifn dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9582, :end-line 9582, :max-fixed-arity 2, :fn-var true, :arglists (quote ([multifn dispatch-val])), :doc "Removes the method of multimethod associated with dispatch-value."}, PersistentQueueSeq {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/PersistentQueueSeq, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 5290, :record false, :end-line 5290, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}}, balance-right-del {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7007, :column 8, :end-line 7007, :end-column 25, :private true, :arglists (quote ([key val left del]))}, :private true, :name cljs.core/balance-right-del, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([key val left del]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7007, :end-line 7007, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val left del]))}, volatile! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4000, :column 7, :end-line 4000, :end-column 16, :arglists (quote ([val])), :doc "Creates and returns a Volatile with an initial value of val."}, :name cljs.core/volatile!, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4000, :end-line 4000, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :doc "Creates and returns a Volatile with an initial value of val."}, / {:protocol-inline nil, :meta {:tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :file "cljs/core.cljs"}, :name cljs.core//, :variadic true, :file "cljs/core.cljs", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2232, :ret-tag number, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators."}, t8242 {:num-fields 2, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t8242, :file "cljs/core.cljs", :type true, :anonymous true, :column 3, :line 3455, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, bitpos {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6039, :column 8, :end-line 6039, :end-column 14, :private true, :arglists (quote ([hash shift]))}, :private true, :name cljs.core/bitpos, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([hash shift]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6039, :end-line 6039, :max-fixed-arity 2, :fn-var true, :arglists (quote ([hash shift]))}, bit-or {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2469, :column 7, :end-line 2469, :end-column 13, :arglists (quote ([x y] [x y & more])), :doc "Bitwise or", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}}, :name cljs.core/bit-or, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2469, :end-line 2469, :max-fixed-arity 2, :fn-var true, :arglists ([x y] [x y & more]), :doc "Bitwise or"}, m3-fmix {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 766, :column 15, :end-line 766, :end-column 22, :tag number, :arglists (quote ([h1 len]))}, :name cljs.core/m3-fmix, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([h1 len]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 766, :ret-tag number, :end-line 766, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([h1 len]))}, vector {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4881, :column 7, :end-line 4881, :end-column 13, :arglists (quote ([& args])), :doc "Creates a new vector containing the args.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}}, :name cljs.core/vector, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}, :method-params [(args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 4881, :end-line 4881, :max-fixed-arity 0, :fn-var true, :arglists ([& args]), :doc "Creates a new vector containing the args."}, hash-coll {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2603, :column 8, :end-line 2603, :end-column 17, :private true, :arglists (quote ([coll]))}, :private true, :name cljs.core/hash-coll, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2603, :end-line 2603, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, clone-and-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6021, :column 8, :end-line 6021, :end-column 21, :private true, :arglists (quote ([arr i a] [arr i a j b])), :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([arr i a] [arr i a j b]), :arglists ([arr i a] [arr i a j b]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/clone-and-set, :variadic false, :file "cljs/core.cljs", :end-column 21, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([arr i a] [arr i a j b]), :arglists ([arr i a] [arr i a j b]), :arglists-meta (nil nil)}, :method-params ([arr i a] [arr i a j b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6021, :end-line 6021, :max-fixed-arity 5, :fn-var true, :arglists ([arr i a] [arr i a j b])}, array->transient-hash-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5999, :column 8, :end-line 5999, :end-column 33, :private true, :arglists (quote ([len arr]))}, :private true, :name cljs.core/array->transient-hash-map, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([len arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5999, :end-line 5999, :max-fixed-arity 2, :fn-var true, :arglists (quote ([len arr]))}, >= {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2275, :column 16, :end-line 2275, :end-column 18, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/>=, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2275, :ret-tag boolean, :end-line 2275, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false."}, ->TransientHashSet {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7869, :column 10, :end-line 7869, :end-column 26, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :factory :positional, :arglists (quote ([transient-map]))}, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name cljs.core/->TransientHashSet, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([transient-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7869, :end-line 7869, :max-fixed-arity 1, :fn-var true, :arglists (quote ([transient-map])), :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}}, drop-last {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4223, :column 7, :end-line 4223, :end-column 16, :arglists (quote ([s] [n s])), :doc "Return a lazy sequence of all but the last n (default 1) items in coll", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([s] [n s]), :arglists ([s] [n s]), :arglists-meta (nil nil)}}, :name cljs.core/drop-last, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([s] [n s]), :arglists ([s] [n s]), :arglists-meta (nil nil)}, :method-params ([s] [n s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4223, :end-line 4223, :max-fixed-arity 2, :fn-var true, :arglists ([s] [n s]), :doc "Return a lazy sequence of all but the last n (default 1) items in coll"}, ->ArrayIter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3473, :column 10, :end-line 3473, :end-column 19, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([arr i]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayIter, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3473, :end-line 3473, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag nil}, object? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 190, :column 16, :end-line 190, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x's constructor is Object"}, :name cljs.core/object?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 190, :ret-tag boolean, :end-line 190, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x's constructor is Object"}, ->ArrayNodeSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6567, :column 10, :end-line 6567, :end-column 22, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta nodes i s __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ArrayNodeSeq, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([meta nodes i s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6567, :end-line 6567, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta nodes i s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, tree-map-append {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7308, :column 8, :end-line 7308, :end-column 23, :private true, :arglists (quote ([left right]))}, :private true, :name cljs.core/tree-map-append, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([left right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7308, :end-line 7308, :max-fixed-arity 2, :fn-var true, :arglists (quote ([left right]))}, not-empty {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3450, :column 7, :end-line 3450, :end-column 16, :arglists (quote ([coll])), :doc "If coll is empty, returns nil, else coll"}, :name cljs.core/not-empty, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3450, :end-line 3450, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "If coll is empty, returns nil, else coll"}, distinct {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8057, :column 7, :end-line 8057, :end-column 15, :arglists (quote ([] [coll])), :doc "Returns a lazy sequence of the elements of coll with duplicates removed", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}}, :name cljs.core/distinct, :variadic false, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}, :method-params ([] [coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8057, :end-line 8057, :max-fixed-arity 1, :fn-var true, :arglists ([] [coll]), :doc "Returns a lazy sequence of the elements of coll with duplicates removed"}, partition {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4452, :column 7, :end-line 4452, :end-column 16, :arglists (quote ([n coll] [n step coll] [n step pad coll])), :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([n coll] [n step coll] [n step pad coll]), :arglists ([n coll] [n step coll] [n step pad coll]), :arglists-meta (nil nil nil)}}, :name cljs.core/partition, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([n coll] [n step coll] [n step pad coll]), :arglists ([n coll] [n step coll] [n step pad coll]), :arglists-meta (nil nil nil)}, :method-params ([n coll] [n step coll] [n step pad coll]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 4452, :end-line 4452, :max-fixed-arity 4, :fn-var true, :arglists ([n coll] [n step coll] [n step pad coll]), :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items."}, IMultiFn {:meta {:file "cljs/core.cljs", :line 9376, :column 14, :end-line 9376, :end-column 22, :doc nil, :protocol-symbol true, :protocol-info {:methods {-prefer-method [[mf dispatch-val dispatch-val-y]], -default-dispatch-val [[mf]], -remove-method [[mf dispatch-val]], -methods [[mf]], -prefers [[mf]], -dispatch-fn [[mf]], -add-method [[mf dispatch-val method]], -reset [[mf]], -get-method [[mf dispatch-val]]}}}, :protocol-symbol true, :name cljs.core/IMultiFn, :file "cljs/core.cljs", :end-column 22, :column 1, :line 9376, :protocol-info {:methods {-prefer-method [[mf dispatch-val dispatch-val-y]], -default-dispatch-val [[mf]], -remove-method [[mf dispatch-val]], -methods [[mf]], -prefers [[mf]], -dispatch-fn [[mf]], -add-method [[mf dispatch-val method]], -reset [[mf]], -get-method [[mf dispatch-val]]}}, :info nil, :end-line 9376, :impls #{cljs.core/MultiFn}, :doc nil}, DEMUNGE_PATTERN {:name cljs.core/DEMUNGE_PATTERN, :file "cljs/core.cljs", :line 312, :column 1, :end-line 312, :end-column 21, :meta {:file "cljs/core.cljs", :line 312, :column 6, :end-line 312, :end-column 21}}, ->t5612 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([nil-iter meta5613])), :file "cljs/core.cljs"}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t5612, :variadic false, :file "cljs/core.cljs", :method-params ([nil-iter meta5613]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :line 3455, :max-fixed-arity 2, :fn-var true, :arglists (quote ([nil-iter meta5613])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, fix {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2401, :column 16, :end-line 2401, :end-column 19, :tag number, :private true, :arglists (quote ([q]))}, :private true, :name cljs.core/fix, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([q]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2401, :ret-tag number, :end-line 2401, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([q]))}, EmptyList {:num-fields 1, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/EmptyList, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 2707, :record false, :end-line 2707, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, IAssociative {:meta {:file "cljs/core.cljs", :line 475, :column 14, :end-line 475, :end-column 26, :doc "Protocol for adding associativity to collections.", :protocol-symbol true, :protocol-info {:methods {-contains-key? [[coll k]], -assoc [[coll k v]]}}}, :protocol-symbol true, :name cljs.core/IAssociative, :file "cljs/core.cljs", :end-column 26, :column 1, :line 475, :protocol-info {:methods {-contains-key? [[coll k]], -assoc [[coll k v]]}}, :info nil, :end-line 475, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap cljs.core/RedNode}, :doc "Protocol for adding associativity to collections."}, bit-flip {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2486, :column 7, :end-line 2486, :end-column 15, :arglists (quote ([x n])), :doc "Flip bit at index n"}, :name cljs.core/bit-flip, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2486, :end-line 2486, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Flip bit at index n"}, long-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3188, :column 7, :end-line 3188, :end-column 17, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}}, :name cljs.core/long-array, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3188, :end-line 3188, :max-fixed-arity 2, :fn-var true, :arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure."}, descendants {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9260, :column 7, :end-line 9260, :end-column 18, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}}, :name cljs.core/descendants, :variadic false, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}, :method-params ([tag] [h tag]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9260, :end-line 9260, :max-fixed-arity 2, :fn-var true, :arglists ([tag] [h tag]), :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships."}, imul {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 745, :column 17, :end-line 745, :end-column 21, :tag number, :arglists (quote ([a b]))}, :name cljs.core/imul, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 3, :line 745, :ret-tag number, :end-line 745, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([a b]))}, ->Delay {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8973, :column 10, :end-line 8973, :end-column 15, :protocols #{cljs.core/IPending cljs.core/IDeref}, :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref}, :factory :positional, :arglists (quote ([f value]))}, :protocols #{cljs.core/IPending cljs.core/IDeref}, :name cljs.core/->Delay, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([f value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 8973, :end-line 8973, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f value])), :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref}}, array-for {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4617, :column 8, :end-line 4617, :end-column 17, :private true, :arglists (quote ([pv i]))}, :private true, :name cljs.core/array-for, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pv i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4617, :end-line 4617, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pv i]))}, merge {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7732, :column 7, :end-line 7732, :end-column 12, :arglists (quote ([& maps])), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(maps)], :arglists ([& maps]), :arglists-meta (nil)}}, :name cljs.core/merge, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(maps)], :arglists ([& maps]), :arglists-meta (nil)}, :method-params [(maps)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 7732, :end-line 7732, :max-fixed-arity 0, :fn-var true, :arglists ([& maps]), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result."}, ISeqable {:meta {:file "cljs/core.cljs", :line 560, :column 14, :end-line 560, :end-column 22, :doc "Protocol for adding the ability to a type to be transformed into a sequence.", :protocol-symbol true, :protocol-info {:methods {-seq [[o]]}}}, :protocol-symbol true, :name cljs.core/ISeqable, :file "cljs/core.cljs", :end-column 22, :column 1, :line 560, :protocol-info {:methods {-seq [[o]]}}, :info nil, :end-line 560, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding the ability to a type to be transformed into a sequence."}, js-mod {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2435, :column 7, :end-line 2435, :end-column 13, :arglists (quote ([n d])), :doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers"}, :name cljs.core/js-mod, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2435, :end-line 2435, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers"}, integer? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1969, :column 16, :end-line 1969, :end-column 24, :tag boolean, :arglists (quote ([n])), :doc "Returns true if n is an integer."}, :name cljs.core/integer?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1969, :ret-tag boolean, :end-line 1969, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is an integer."}, MetaFn {:num-fields 2, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :name cljs.core/MetaFn, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 1737, :record false, :end-line 1737, :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}}, mapv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4427, :column 7, :end-line 4427, :end-column 11, :arglists (quote ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f coll] [f c1 c2] [f c1 c2 c3]), :arglists ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/mapv, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f coll] [f c1 c2] [f c1 c2 c3]), :arglists ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :arglists-meta (nil nil nil nil)}, :method-params ([f coll] [f c1 c2] [f c1 c2 c3]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 4427, :end-line 4427, :max-fixed-arity 4, :fn-var true, :arglists ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments."}, partition-all {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8136, :column 7, :end-line 8136, :end-column 20, :arglists (quote ([n] [n coll] [n step coll])), :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([n] [n coll] [n step coll]), :arglists ([n] [n coll] [n step coll]), :arglists-meta (nil nil nil)}}, :name cljs.core/partition-all, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([n] [n coll] [n step coll]), :arglists ([n] [n coll] [n step coll]), :arglists-meta (nil nil nil)}, :method-params ([n] [n coll] [n step coll]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 8136, :end-line 8136, :max-fixed-arity 3, :fn-var true, :arglists ([n] [n coll] [n step coll]), :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided."}, partition-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8356, :column 7, :end-line 8356, :end-column 19, :arglists (quote ([f] [f coll])), :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name cljs.core/partition-by, :variadic false, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8356, :end-line 8356, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided."}, ISequential {:meta {:file "cljs/core.cljs", :line 565, :column 14, :end-line 565, :end-column 25, :doc "Marker interface indicating a persistent collection of sequential items", :protocol-symbol true, :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/ISequential, :file "cljs/core.cljs", :end-column 25, :column 1, :line 565, :protocol-info {:methods {}}, :info nil, :end-line 565, :impls #{cljs.core/Cons cljs.core/Eduction cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Marker interface indicating a persistent collection of sequential items"}, ->LazySeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2940, :column 10, :end-line 2940, :end-column 17, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta fn s __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->LazySeq, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([meta fn s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 2940, :end-line 2940, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta fn s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, equiv-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5397, :column 8, :end-line 5397, :end-column 17, :private true, :arglists (quote ([x y])), :doc "Assumes y is a map. Returns true if x equals y, otherwise returns\n  false."}, :private true, :name cljs.core/equiv-map, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5397, :end-line 5397, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Assumes y is a map. Returns true if x equals y, otherwise returns\n  false."}, ->Volatile {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3992, :column 10, :end-line 3992, :end-column 18, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :skip-protocol-flag #{cljs.core/IDeref}, :factory :positional, :arglists (quote ([state]))}, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :name cljs.core/->Volatile, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([state]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3992, :end-line 3992, :max-fixed-arity 1, :fn-var true, :arglists (quote ([state])), :skip-protocol-flag #{cljs.core/IDeref}}, object-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3232, :column 7, :end-line 3232, :end-column 19, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}}, :name cljs.core/object-array, :variadic false, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3232, :end-line 3232, :max-fixed-arity 2, :fn-var true, :arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure."}, Keyword {:meta {:file "cljs/core.cljs", :line 158, :column 20, :end-line 158, :end-column 27, :declared true}, :num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :name cljs.core/Keyword, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 2875, :record false, :declared true, :end-line 2875, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}}, derive {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9269, :column 7, :end-line 9269, :end-column 13, :arglists (quote ([tag parent] [h tag parent])), :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([tag parent] [h tag parent]), :arglists ([tag parent] [h tag parent]), :arglists-meta (nil nil)}}, :name cljs.core/derive, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([tag parent] [h tag parent]), :arglists ([tag parent] [h tag parent]), :arglists-meta (nil nil)}, :method-params ([tag parent] [h tag parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9269, :end-line 9269, :max-fixed-arity 3, :fn-var true, :arglists ([tag parent] [h tag parent]), :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy."}, seq-iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3506, :column 7, :end-line 3506, :end-column 15, :arglists (quote ([coll]))}, :name cljs.core/seq-iter, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3506, :end-line 3506, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, IChunkedSeq {:meta {:file "cljs/core.cljs", :line 673, :column 14, :end-line 673, :end-column 25, :doc "Protocol for accessing a collection as sequential chunks.", :protocol-symbol true, :protocol-info {:methods {-chunked-first [[coll]], -chunked-rest [[coll]]}}}, :protocol-symbol true, :name cljs.core/IChunkedSeq, :file "cljs/core.cljs", :end-column 25, :column 1, :line 673, :protocol-info {:methods {-chunked-first [[coll]], -chunked-rest [[coll]]}}, :info nil, :end-line 673, :impls #{cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :doc "Protocol for accessing a collection as sequential chunks."}, special-symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9737, :column 16, :end-line 9737, :end-column 31, :tag boolean, :arglists (quote ([x]))}, :name cljs.core/special-symbol?, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9737, :ret-tag boolean, :end-line 9737, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x]))}, compare-keywords {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2863, :column 8, :end-line 2863, :end-column 24, :private true, :arglists (quote ([a b]))}, :private true, :name cljs.core/compare-keywords, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2863, :end-line 2863, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, ancestors {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9252, :column 7, :end-line 9252, :end-column 16, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}}, :name cljs.core/ancestors, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}, :method-params ([tag] [h tag]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9252, :end-line 9252, :max-fixed-arity 2, :fn-var true, :arglists ([tag] [h tag]), :doc "Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy"}, subseq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8192, :column 7, :end-line 8192, :end-column 13, :arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :arglists ([sc test key] [sc start-test start-key end-test end-key]), :arglists-meta (nil nil)}}, :name cljs.core/subseq, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :arglists ([sc test key] [sc start-test start-key end-test end-key]), :arglists-meta (nil nil)}, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8192, :end-line 8192, :max-fixed-arity 5, :fn-var true, :arglists ([sc test key] [sc start-test start-key end-test end-key]), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true"}, LazyTransformer {:meta {:file "cljs/core.cljs", :line 3518, :column 10, :end-line 3518, :end-column 25, :declared true}, :num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/LazyTransformer, :file "cljs/core.cljs", :end-column 25, :type true, :column 10, :line 3597, :record false, :declared true, :end-line 3597, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}}, gensym {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8956, :column 7, :end-line 8956, :end-column 13, :arglists (quote ([] [prefix-string])), :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [prefix-string]), :arglists ([] [prefix-string]), :arglists-meta (nil nil)}}, :name cljs.core/gensym, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [prefix-string]), :arglists ([] [prefix-string]), :arglists-meta (nil nil)}, :method-params ([] [prefix-string]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8956, :end-line 8956, :max-fixed-arity 1, :fn-var true, :arglists ([] [prefix-string]), :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'."}, -next {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 463, :column 16, :end-line 463, :end-column 21, :tag clj-or-nil, :protocol cljs.core/INext, :doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil", :arglists (quote ([coll]))}, :protocol cljs.core/INext, :name cljs.core/-next, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 461, :ret-tag clj-or-nil, :end-line 463, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil"}, ->HashCollisionNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6388, :column 10, :end-line 6388, :end-column 27, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([edit collision-hash cnt arr]))}, :protocols #{cljs.core/Object}, :name cljs.core/->HashCollisionNode, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([edit collision-hash cnt arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6388, :end-line 6388, :max-fixed-arity 4, :fn-var true, :arglists (quote ([edit collision-hash cnt arr])), :skip-protocol-flag nil}, delay? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8985, :column 16, :end-line 8985, :end-column 22, :tag boolean, :arglists (quote ([x])), :doc "returns true if x is a Delay created with delay"}, :name cljs.core/delay?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8985, :ret-tag boolean, :end-line 8985, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "returns true if x is a Delay created with delay"}, create-inode-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6550, :column 8, :end-line 6550, :end-column 24, :private true, :arglists (quote ([nodes] [nodes i s])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([nodes] [nodes i s]), :arglists ([nodes] [nodes i s]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/create-inode-seq, :variadic false, :file "cljs/core.cljs", :end-column 24, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([nodes] [nodes i s]), :arglists ([nodes] [nodes i s]), :arglists-meta (nil nil)}, :method-params ([nodes] [nodes i s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6550, :end-line 6550, :max-fixed-arity 3, :fn-var true, :arglists ([nodes] [nodes i s])}, flatten {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4405, :column 7, :end-line 4405, :end-column 14, :arglists (quote ([x])), :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil."}, :name cljs.core/flatten, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4405, :end-line 4405, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil."}, -dissoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 487, :column 9, :end-line 487, :end-column 16, :tag clj, :protocol cljs.core/IMap, :doc "Returns a new collection of coll without the mapping for key k.", :arglists (quote ([coll k]))}, :protocol cljs.core/IMap, :name cljs.core/-dissoc, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 484, :ret-tag clj, :end-line 487, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll k])), :doc "Returns a new collection of coll without the mapping for key k."}, doubles {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2432, :column 7, :end-line 2432, :end-column 14, :arglists (quote ([x]))}, :name cljs.core/doubles, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2432, :end-line 2432, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, -contains-key? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 477, :column 13, :end-line 477, :end-column 27, :tag boolean, :protocol cljs.core/IAssociative, :doc "Returns true if k is a key in coll.", :arglists (quote ([coll k]))}, :protocol cljs.core/IAssociative, :name cljs.core/-contains-key?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 475, :ret-tag boolean, :end-line 477, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([coll k])), :doc "Returns true if k is a key in coll."}, remove-watch {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8944, :column 7, :end-line 8944, :end-column 19, :arglists (quote ([iref key])), :doc "Alpha - subject to change.\n\n  Removes a watch (set by add-watch) from a reference"}, :name cljs.core/remove-watch, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([iref key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8944, :end-line 8944, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref key])), :doc "Alpha - subject to change.\n\n  Removes a watch (set by add-watch) from a reference"}, ex-info {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9698, :column 7, :end-line 9698, :end-column 14, :arglists (quote ([msg data] [msg data cause])), :doc "Alpha - subject to change.\n  Create an instance of ExceptionInfo, an Error type that carries a\n  map of additional data.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([msg data] [msg data cause]), :arglists ([msg data] [msg data cause]), :arglists-meta (nil nil)}}, :name cljs.core/ex-info, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([msg data] [msg data cause]), :arglists ([msg data] [msg data cause]), :arglists-meta (nil nil)}, :method-params ([msg data] [msg data cause]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9698, :end-line 9698, :max-fixed-arity 3, :fn-var true, :arglists ([msg data] [msg data cause]), :doc "Alpha - subject to change.\n  Create an instance of ExceptionInfo, an Error type that carries a\n  map of additional data."}, ifn? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1964, :column 16, :end-line 1964, :end-column 20, :tag boolean, :arglists (quote ([f])), :doc "Returns true if f returns true for fn? or satisfies IFn."}, :name cljs.core/ifn?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1964, :ret-tag boolean, :end-line 1964, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :doc "Returns true if f returns true for fn? or satisfies IFn."}, IAtom {:meta {:file "cljs/core.cljs", :line 692, :column 14, :end-line 692, :end-column 19, :doc "Marker protocol indicating an atom.", :protocol-symbol true, :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/IAtom, :file "cljs/core.cljs", :end-column 19, :column 1, :line 692, :protocol-info {:methods {}}, :info nil, :end-line 692, :impls #{cljs.core/Atom}, :doc "Marker protocol indicating an atom."}, ->PersistentQueue {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5330, :column 10, :end-line 5330, :end-column 25, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([meta count front rear __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->PersistentQueue, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([meta count front rear __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5330, :end-line 5330, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta count front rear __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}}, IWatchable {:meta {:file "cljs/core.cljs", :line 617, :column 14, :end-line 617, :end-column 24, :doc "Protocol for types that can be watched. Currently only implemented by Atom.", :protocol-symbol true, :protocol-info {:methods {-notify-watches [[this oldval newval]], -add-watch [[this key f]], -remove-watch [[this key]]}}}, :protocol-symbol true, :name cljs.core/IWatchable, :file "cljs/core.cljs", :end-column 24, :column 1, :line 617, :protocol-info {:methods {-notify-watches [[this oldval newval]], -add-watch [[this key f]], -remove-watch [[this key]]}}, :info nil, :end-line 617, :impls #{cljs.core/Atom}, :doc "Protocol for types that can be watched. Currently only implemented by Atom."}, ->Stepper {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3523, :column 10, :end-line 3523, :end-column 17, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([xform iter]))}, :protocols #{cljs.core/Object}, :name cljs.core/->Stepper, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([xform iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3523, :end-line 3523, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform iter])), :skip-protocol-flag nil}, pv-fresh-node {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4551, :column 8, :end-line 4551, :end-column 21, :private true, :arglists (quote ([edit]))}, :private true, :name cljs.core/pv-fresh-node, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([edit]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4551, :end-line 4551, :max-fixed-arity 1, :fn-var true, :arglists (quote ([edit]))}, subvec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5091, :column 7, :end-line 5091, :end-column 13, :arglists (quote ([v start] [v start end])), :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([v start] [v start end]), :arglists ([v start] [v start end]), :arglists-meta (nil nil)}}, :name cljs.core/subvec, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([v start] [v start end]), :arglists ([v start] [v start end]), :arglists-meta (nil nil)}, :method-params ([v start] [v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5091, :end-line 5091, :max-fixed-arity 3, :fn-var true, :arglists ([v start] [v start end]), :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done."}, -pop! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 654, :column 9, :end-line 654, :end-column 14, :tag clj, :protocol cljs.core/ITransientVector, :doc "Returns tcoll with the last item removed from it.", :arglists (quote ([tcoll]))}, :protocol cljs.core/ITransientVector, :name cljs.core/-pop!, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 650, :ret-tag clj, :end-line 654, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([tcoll])), :doc "Returns tcoll with the last item removed from it."}, partial {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3768, :column 7, :end-line 3768, :end-column 14, :arglists (quote ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more])), :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3]), :arglists ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/partial, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3]), :arglists ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]), :arglists-meta (nil nil nil nil nil)}, :method-params ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 3768, :end-line 3768, :max-fixed-arity 4, :fn-var true, :arglists ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]), :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args."}, chunked-seq? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1889, :column 16, :end-line 1889, :end-column 28, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is satisfies IChunkedSeq."}, :name cljs.core/chunked-seq?, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1889, :ret-tag boolean, :end-line 1889, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is satisfies IChunkedSeq."}, replicate {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4278, :column 7, :end-line 4278, :end-column 16, :arglists (quote ([n x])), :doc "Returns a lazy seq of n xs."}, :name cljs.core/replicate, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([n x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4278, :end-line 4278, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n x])), :doc "Returns a lazy seq of n xs."}, PersistentQueue {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/PersistentQueue, :file "cljs/core.cljs", :end-column 25, :type true, :column 10, :line 5330, :record false, :end-line 5330, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}}, min-key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8118, :column 7, :end-line 8118, :end-column 14, :arglists (quote ([k x] [k x y] [k x y & more])), :doc "Returns the x for which (k x), a number, is least.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([k x] [k x y]), :arglists ([k x] [k x y] [k x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/min-key, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([k x] [k x y]), :arglists ([k x] [k x y] [k x y & more]), :arglists-meta (nil nil nil)}, :method-params ([k x] [k x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 8118, :end-line 8118, :max-fixed-arity 3, :fn-var true, :arglists ([k x] [k x y] [k x y & more]), :doc "Returns the x for which (k x), a number, is least."}, hash-iset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2623, :column 8, :end-line 2623, :end-column 17, :private true, :arglists (quote ([s]))}, :private true, :name cljs.core/hash-iset, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2623, :end-line 2623, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, reduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1224, :column 7, :end-line 1224, :end-column 14, :arglists (quote ([x])), :doc "Wraps x in a way such that a reduce will terminate with the value x"}, :name cljs.core/reduced, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1224, :end-line 1224, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Wraps x in a way such that a reduce will terminate with the value x"}, re-matches {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8490, :column 7, :end-line 8490, :end-column 17, :arglists (quote ([re s])), :doc "Returns the result of (re-find re s) if re fully matches s."}, :name cljs.core/re-matches, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8490, :end-line 8490, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns the result of (re-find re s) if re fully matches s."}, pr-writer-impl {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8589, :column 8, :end-line 8589, :end-column 22, :private true, :arglists (quote ([obj writer opts]))}, :private true, :name cljs.core/pr-writer-impl, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([obj writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8589, :end-line 8589, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts]))}, array-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7555, :column 7, :end-line 7555, :end-column 16, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new array map with supplied mappings.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name cljs.core/array-map, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 7555, :end-line 7555, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new array map with supplied mappings."}, ITransientSet {:meta {:file "cljs/core.cljs", :line 657, :column 14, :end-line 657, :end-column 27, :doc "Protocol for adding set functionality to a transient collection.", :protocol-symbol true, :protocol-info {:methods {-disjoin! [[tcoll v]]}}}, :protocol-symbol true, :name cljs.core/ITransientSet, :file "cljs/core.cljs", :end-column 27, :column 1, :line 657, :protocol-info {:methods {-disjoin! [[tcoll v]]}}, :info nil, :end-line 657, :impls #{cljs.core/TransientHashSet}, :doc "Protocol for adding set functionality to a transient collection."}, ITER_SYMBOL {:name cljs.core/ITER_SYMBOL, :file "cljs/core.cljs", :line 256, :column 3, :end-line 256, :end-column 19, :meta {:file "cljs/core.cljs", :line 256, :column 8, :end-line 256, :end-column 19}}, unchecked-byte {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2319, :column 15, :end-line 2319, :end-column 29, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-byte, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2319, :ret-tag number, :end-line 2319, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, ArrayNode {:meta {:file "cljs/core.cljs", :line 6069, :column 10, :end-line 6069, :end-column 19, :declared true}, :num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/ArrayNode, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 6282, :record false, :declared true, :end-line 6282, :skip-protocol-flag nil}, ->ChunkedSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4890, :column 10, :end-line 4890, :end-column 20, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([vec node i off meta __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ChunkedSeq, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([vec node i off meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 4890, :end-line 4890, :max-fixed-arity 6, :fn-var true, :arglists (quote ([vec node i off meta __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, every-pred {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4050, :column 7, :end-line 4050, :end-column 17, :arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([p] [p1 p2] [p1 p2 p3]), :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/every-pred, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([p] [p1 p2] [p1 p2 p3]), :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :arglists-meta (nil nil nil nil)}, :method-params ([p] [p1 p2] [p1 p2 p3]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 4050, :end-line 4050, :max-fixed-arity 3, :fn-var true, :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates."}, keys {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7653, :column 7, :end-line 7653, :end-column 11, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's keys."}, :name cljs.core/keys, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([hash-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7653, :end-line 7653, :max-fixed-arity 1, :fn-var true, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's keys."}, missing-protocol {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 234, :column 7, :end-line 234, :end-column 23, :arglists (quote ([proto obj]))}, :name cljs.core/missing-protocol, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([proto obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 234, :end-line 234, :max-fixed-arity 2, :fn-var true, :arglists (quote ([proto obj]))}, load-file {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 249, :column 7, :end-line 249, :end-column 16, :arglists (quote ([file]))}, :name cljs.core/load-file, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([file]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 249, :end-line 249, :max-fixed-arity 1, :fn-var true, :arglists (quote ([file]))}, PersistentArrayMap {:num-fields 4, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/PersistentArrayMap, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 5744, :record false, :end-line 5744, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}}, distinct? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1996, :column 16, :end-line 1996, :end-column 25, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns true if no two of the arguments are =", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/distinct?, :variadic true, :file "cljs/core.cljs", :end-column 25, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1996, :ret-tag boolean, :end-line 1996, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns true if no two of the arguments are ="}, never-equiv {:name cljs.core/never-equiv, :file "cljs/core.cljs", :line 5395, :column 1, :end-line 5395, :end-column 27, :private true, :meta {:file "cljs/core.cljs", :line 5395, :column 16, :end-line 5395, :end-column 27, :private true}}, Stepper {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/Stepper, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 3523, :record false, :end-line 3523, :skip-protocol-flag nil}, unchecked-short {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2321, :column 15, :end-line 2321, :end-column 30, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-short, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2321, :ret-tag number, :end-line 2321, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, ->Range {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8233, :column 10, :end-line 8233, :end-column 15, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta start end step __hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->Range, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([meta start end step __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 8233, :end-line 8233, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta start end step __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, methods {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9593, :column 7, :end-line 9593, :end-column 14, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns"}, :name cljs.core/methods, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9593, :end-line 9593, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns"}, odd? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3721, :column 16, :end-line 3721, :end-column 20, :tag boolean, :arglists (quote ([n])), :doc "Returns true if n is odd, throws an exception if n is not an integer"}, :name cljs.core/odd?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3721, :ret-tag boolean, :end-line 3721, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is odd, throws an exception if n is not an integer"}, ->ArrayChunk {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3025, :column 10, :end-line 3025, :end-column 20, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}, :factory :positional, :arglists (quote ([arr off end]))}, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :name cljs.core/->ArrayChunk, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([arr off end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3025, :end-line 3025, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr off end])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}}, lazy-transformer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3520, :column 7, :end-line 3520, :end-column 23, :arglists (quote ([stepper]))}, :name cljs.core/lazy-transformer, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([stepper]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3520, :end-line 3520, :max-fixed-arity 1, :fn-var true, :arglists (quote ([stepper]))}, ci-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1254, :column 8, :end-line 1254, :end-column 17, :private true, :arglists (quote ([cicoll f] [cicoll f val] [cicoll f val idx])), :doc "Accepts any collection which satisfies the ICount and IIndexed protocols and\nreduces them without incurring seq initialization", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([cicoll f] [cicoll f val] [cicoll f val idx]), :arglists ([cicoll f] [cicoll f val] [cicoll f val idx]), :arglists-meta (nil nil nil)}}, :private true, :name cljs.core/ci-reduce, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([cicoll f] [cicoll f val] [cicoll f val idx]), :arglists ([cicoll f] [cicoll f val] [cicoll f val idx]), :arglists-meta (nil nil nil)}, :method-params ([cicoll f] [cicoll f val] [cicoll f val idx]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1254, :end-line 1254, :max-fixed-arity 4, :fn-var true, :arglists ([cicoll f] [cicoll f val] [cicoll f val idx]), :doc "Accepts any collection which satisfies the ICount and IIndexed protocols and\nreduces them without incurring seq initialization"}, *3 {:name cljs.core/*3, :file "cljs/core.cljs", :line 143, :column 1, :end-line 145, :end-column 5, :doc "bound in a repl thread to the third most recent value printed", :meta {:file "cljs/core.cljs", :line 145, :column 3, :end-line 145, :end-column 5, :doc "bound in a repl thread to the third most recent value printed"}}, -get-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9381, :column 4, :end-line 9381, :end-column 15, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf dispatch-val]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-get-method, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([mf dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9376, :end-line 9381, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf dispatch-val])), :doc nil}, ->Var {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 943, :column 10, :end-line 943, :end-column 13, :protocols #{cljs.core/IFn cljs.core/Object cljs.core/IMeta cljs.core/Fn cljs.core/IDeref}, :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IDeref}, :factory :positional, :arglists (quote ([val sym _meta]))}, :protocols #{cljs.core/IFn cljs.core/Object cljs.core/IMeta cljs.core/Fn cljs.core/IDeref}, :name cljs.core/->Var, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([val sym _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 943, :end-line 943, :max-fixed-arity 3, :fn-var true, :arglists (quote ([val sym _meta])), :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IDeref}}, frequencies {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8397, :column 7, :end-line 8397, :end-column 18, :arglists (quote ([coll])), :doc "Returns a map from distinct items in coll to the number of times\n  they appear."}, :name cljs.core/frequencies, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8397, :end-line 8397, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a map from distinct items in coll to the number of times\n  they appear."}, t8245 {:num-fields 2, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t8245, :file "cljs/core.cljs", :type true, :anonymous true, :column 3, :line 3455, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, reduceable? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1867, :column 16, :end-line 1867, :end-column 27, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll satisfies IReduce"}, :name cljs.core/reduceable?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1867, :ret-tag boolean, :end-line 1867, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies IReduce"}, string-hash-cache {:name cljs.core/string-hash-cache, :file "cljs/core.cljs", :line 801, :column 1, :end-line 801, :end-column 23, :meta {:file "cljs/core.cljs", :line 801, :column 6, :end-line 801, :end-column 23}}, rsubseq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8207, :column 7, :end-line 8207, :end-column 14, :arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :arglists ([sc test key] [sc start-test start-key end-test end-key]), :arglists-meta (nil nil)}}, :name cljs.core/rsubseq, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :arglists ([sc test key] [sc start-test start-key end-test end-key]), :arglists-meta (nil nil)}, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8207, :end-line 8207, :max-fixed-arity 5, :fn-var true, :arglists ([sc test key] [sc start-test start-key end-test end-key]), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true"}, inc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1214, :column 7, :end-line 1214, :end-column 10, :arglists (quote ([x])), :doc "Returns a number one greater than num."}, :name cljs.core/inc, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1214, :end-line 1214, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one greater than num."}, type->str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 243, :column 7, :end-line 243, :end-column 16, :arglists (quote ([ty]))}, :name cljs.core/type->str, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([ty]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 243, :end-line 243, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ty]))}, obj-clone {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5447, :column 8, :end-line 5447, :end-column 17, :private true, :arglists (quote ([obj ks]))}, :private true, :name cljs.core/obj-clone, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([obj ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5447, :end-line 5447, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj ks]))}, get-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9597, :column 7, :end-line 9597, :end-column 17, :arglists (quote ([multifn dispatch-val])), :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default"}, :name cljs.core/get-method, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([multifn dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9597, :end-line 9597, :max-fixed-arity 2, :fn-var true, :arglists (quote ([multifn dispatch-val])), :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default"}, vector-index-out-of-bounds {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4595, :column 8, :end-line 4595, :end-column 34, :private true, :arglists (quote ([i cnt]))}, :private true, :name cljs.core/vector-index-out-of-bounds, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([i cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4595, :end-line 4595, :max-fixed-arity 2, :fn-var true, :arglists (quote ([i cnt]))}, es6-entries-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5577, :column 7, :end-line 5577, :end-column 27, :arglists (quote ([coll]))}, :name cljs.core/es6-entries-iterator, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5577, :end-line 5577, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, bit-clear {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2481, :column 7, :end-line 2481, :end-column 16, :arglists (quote ([x n])), :doc "Clear bit at index n"}, :name cljs.core/bit-clear, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2481, :end-line 2481, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Clear bit at index n"}, ->t8242 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([nil-iter meta8243])), :file "cljs/core.cljs"}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t8242, :variadic false, :file "cljs/core.cljs", :method-params ([nil-iter meta8243]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :line 3455, :max-fixed-arity 2, :fn-var true, :arglists (quote ([nil-iter meta8243])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, Range {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/Range, :file "cljs/core.cljs", :end-column 15, :type true, :column 10, :line 8233, :record false, :end-line 8233, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, filter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4353, :column 7, :end-line 4353, :end-column 13, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name cljs.core/filter, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4353, :end-line 4353, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."}, ->PersistentTreeMapSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6883, :column 10, :end-line 6883, :end-column 30, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta stack ascending? cnt __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->PersistentTreeMapSeq, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([meta stack ascending? cnt __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6883, :end-line 6883, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta stack ascending? cnt __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, create-array-node-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6606, :column 8, :end-line 6606, :end-column 29, :private true, :arglists (quote ([nodes] [meta nodes i s])), :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([nodes] [meta nodes i s]), :arglists ([nodes] [meta nodes i s]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/create-array-node-seq, :variadic false, :file "cljs/core.cljs", :end-column 29, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([nodes] [meta nodes i s]), :arglists ([nodes] [meta nodes i s]), :arglists-meta (nil nil)}, :method-params ([nodes] [meta nodes i s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6606, :end-line 6606, :max-fixed-arity 4, :fn-var true, :arglists ([nodes] [meta nodes i s])}, -assoc-n! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 652, :column 9, :end-line 652, :end-column 18, :tag clj, :protocol cljs.core/ITransientVector, :doc "Returns tcoll with value val added at position n.", :arglists (quote ([tcoll n val]))}, :protocol cljs.core/ITransientVector, :name cljs.core/-assoc-n!, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([tcoll n val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 650, :ret-tag clj, :end-line 652, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([tcoll n val])), :doc "Returns tcoll with value val added at position n."}, IWithMeta {:meta {:file "cljs/core.cljs", :line 530, :column 14, :end-line 530, :end-column 23, :doc "Protocol for adding metadata to an object.", :protocol-symbol true, :protocol-info {:methods {-with-meta [[o meta]]}}}, :protocol-symbol true, :name cljs.core/IWithMeta, :file "cljs/core.cljs", :end-column 23, :column 1, :line 530, :protocol-info {:methods {-with-meta [[o meta]]}}, :info nil, :end-line 530, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/t8242 cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/MetaFn cljs.core/LazyTransformer cljs.core/Range cljs.core/t8245 cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding metadata to an object."}, list {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2781, :column 7, :end-line 2781, :end-column 11, :arglists (quote ([& xs])), :doc "Creates a new list containing the items.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(xs)], :arglists ([& xs]), :arglists-meta (nil)}}, :name cljs.core/list, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(xs)], :arglists ([& xs]), :arglists-meta (nil)}, :method-params [(xs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 2781, :end-line 2781, :max-fixed-arity 0, :fn-var true, :arglists ([& xs]), :doc "Creates a new list containing the items."}, + {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2208, :column 15, :end-line 2208, :end-column 16, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/+, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 2208, :ret-tag number, :end-line 2208, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the sum of nums. (+) returns 0."}, IndexedSeqIterator {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/IndexedSeqIterator, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 1328, :record false, :end-line 1328, :skip-protocol-flag nil}, split-with {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8351, :column 7, :end-line 8351, :end-column 17, :arglists (quote ([pred coll])), :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"}, :name cljs.core/split-with, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8351, :end-line 8351, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"}, ->VectorNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4549, :column 10, :end-line 4549, :end-column 20, :protocols #{}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([edit arr]))}, :protocols #{}, :name cljs.core/->VectorNode, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([edit arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 4549, :end-line 4549, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit arr])), :skip-protocol-flag nil}, aset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 354, :column 7, :end-line 354, :end-column 11, :arglists (quote ([array i val] [array idx idx2 & idxv])), :doc "Sets the value at the index.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([array i val]), :arglists ([array i val] [array idx idx2 & idxv]), :arglists-meta (nil nil)}}, :name cljs.core/aset, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([array i val]), :arglists ([array i val] [array idx idx2 & idxv]), :arglists-meta (nil nil)}, :method-params ([array i val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 354, :end-line 354, :max-fixed-arity 3, :fn-var true, :arglists ([array i val] [array idx idx2 & idxv]), :doc "Sets the value at the index."}, int-rotate-left {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 736, :column 15, :end-line 736, :end-column 30, :tag number, :arglists (quote ([x n]))}, :name cljs.core/int-rotate-left, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 736, :ret-tag number, :end-line 736, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x n]))}, keyword {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2925, :column 7, :end-line 2925, :end-column 14, :arglists (quote ([name] [ns name])), :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([name] [ns name]), :arglists ([name] [ns name]), :arglists-meta (nil nil)}}, :name cljs.core/keyword, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([name] [ns name]), :arglists ([name] [ns name]), :arglists-meta (nil nil)}, :method-params ([name] [ns name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2925, :end-line 2925, :max-fixed-arity 2, :fn-var true, :arglists ([name] [ns name]), :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically."}, ->Cons {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2798, :column 10, :end-line 2798, :end-column 14, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta first rest __hash]))}, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->Cons, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([meta first rest __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 2798, :end-line 2798, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta first rest __hash])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, *ns* {:name cljs.core/*ns*, :file "cljs/core.cljs", :line 29, :column 1, :end-line 32, :end-column 7, :dynamic true, :doc "Var bound to the current namespace. Only used for bootstrapping.", :meta {:file "cljs/core.cljs", :line 32, :column 3, :end-line 32, :end-column 7, :dynamic true, :doc "Var bound to the current namespace. Only used for bootstrapping."}}, *assert* {:name cljs.core/*assert*, :file "cljs/core.cljs", :line 42, :column 1, :end-line 44, :end-column 11, :dynamic true, :meta {:file "cljs/core.cljs", :line 44, :column 3, :end-line 44, :end-column 11, :dynamic true}}, create-tree-map-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6936, :column 8, :end-line 6936, :end-column 27, :private true, :arglists (quote ([tree ascending? cnt]))}, :private true, :name cljs.core/create-tree-map-seq, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([tree ascending? cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6936, :end-line 6936, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tree ascending? cnt]))}, ICollection {:meta {:file "cljs/core.cljs", :line 431, :column 14, :end-line 431, :end-column 25, :doc "Protocol for adding to a collection.", :protocol-symbol true, :protocol-info {:methods {-conj [[coll o]]}}}, :protocol-symbol true, :name cljs.core/ICollection, :file "cljs/core.cljs", :end-column 25, :column 1, :line 431, :protocol-info {:methods {-conj [[coll o]]}}, :info nil, :end-line 431, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding to a collection."}, multi-stepper {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3577, :column 7, :end-line 3577, :end-column 20, :arglists (quote ([xform iters] [xform iters nexts])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([xform iters] [xform iters nexts]), :arglists ([xform iters] [xform iters nexts]), :arglists-meta (nil nil)}}, :name cljs.core/multi-stepper, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([xform iters] [xform iters nexts]), :arglists ([xform iters] [xform iters nexts]), :arglists-meta (nil nil)}, :method-params ([xform iters] [xform iters nexts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3577, :end-line 3577, :max-fixed-arity 3, :fn-var true, :arglists ([xform iters] [xform iters nexts])}, chars {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2428, :column 7, :end-line 2428, :end-column 12, :arglists (quote ([x]))}, :name cljs.core/chars, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2428, :end-line 2428, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2566, :column 7, :end-line 2566, :end-column 10, :arglists (quote ([] [x] [x & ys])), :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([] [x]), :arglists ([] [x] [x & ys]), :arglists-meta (nil nil nil)}}, :name cljs.core/str, :variadic true, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([] [x]), :arglists ([] [x] [x & ys]), :arglists-meta (nil nil nil)}, :method-params ([] [x]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2566, :end-line 2566, :max-fixed-arity 1, :fn-var true, :arglists ([] [x] [x & ys]), :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args."}, next {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1069, :column 12, :end-line 1069, :end-column 16, :tag seq, :arglists (quote ([coll])), :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil"}, :name cljs.core/next, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1069, :ret-tag seq, :end-line 1069, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil"}, ASeq {:meta {:file "cljs/core.cljs", :line 448, :column 14, :end-line 448, :end-column 18, :doc "Marker protocol indicating an array sequence.", :protocol-symbol true, :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/ASeq, :file "cljs/core.cljs", :end-column 18, :column 1, :line 448, :protocol-info {:methods {}}, :info nil, :end-line 448, :impls #{cljs.core/Cons cljs.core/IndexedSeq cljs.core/List cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :doc "Marker protocol indicating an array sequence."}, pr-seq-writer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8666, :column 7, :end-line 8666, :end-column 20, :arglists (quote ([objs writer opts]))}, :name cljs.core/pr-seq-writer, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([objs writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8666, :end-line 8666, :max-fixed-arity 3, :fn-var true, :arglists (quote ([objs writer opts]))}, SeqIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/SeqIter, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 3488, :record false, :end-line 3488, :skip-protocol-flag nil}, IFn {:meta {:file "cljs/core.cljs", :line 387, :column 14, :end-line 387, :end-column 17, :doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2", :protocol-symbol true, :protocol-info {:methods {-invoke [[this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]]}}}, :protocol-symbol true, :name cljs.core/IFn, :file "cljs/core.cljs", :end-column 17, :column 1, :line 387, :protocol-info {:methods {-invoke [[this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]]}}, :info nil, :end-line 387, :impls #{cljs.core/PersistentHashMap cljs.core/MultiFn cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/Keyword cljs.core/BlackNode cljs.core/Subvec cljs.core/Var cljs.core/PersistentVector cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/Symbol cljs.core/MetaFn cljs.core/RedNode}, :doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2"}, regexp? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8485, :column 7, :end-line 8485, :end-column 14, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript RegExp instance."}, :name cljs.core/regexp?, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8485, :end-line 8485, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript RegExp instance."}, hash-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7546, :column 7, :end-line 7546, :end-column 15, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new hash map with supplied mappings.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name cljs.core/hash-map, :variadic true, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 7546, :end-line 7546, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new hash map with supplied mappings."}, underive {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9303, :column 7, :end-line 9303, :end-column 15, :arglists (quote ([tag parent] [h tag parent])), :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([tag parent] [h tag parent]), :arglists ([tag parent] [h tag parent]), :arglists-meta (nil nil)}}, :name cljs.core/underive, :variadic false, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([tag parent] [h tag parent]), :arglists ([tag parent] [h tag parent]), :arglists-meta (nil nil)}, :method-params ([tag parent] [h tag parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9303, :end-line 9303, :max-fixed-arity 3, :fn-var true, :arglists ([tag parent] [h tag parent]), :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy."}, array-copy {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1914, :column 8, :end-line 1914, :end-column 18, :private true, :arglists (quote ([from i to j len]))}, :private true, :name cljs.core/array-copy, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([from i to j len]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1914, :end-line 1914, :max-fixed-arity 5, :fn-var true, :arglists (quote ([from i to j len]))}, obj-map-compare-keys {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5425, :column 8, :end-line 5425, :end-column 28, :private true, :arglists (quote ([a b]))}, :private true, :name cljs.core/obj-map-compare-keys, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5425, :end-line 5425, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, -reset! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 697, :column 4, :end-line 697, :end-column 11, :protocol cljs.core/IReset, :doc "Sets the value of o to new-value.", :arglists (quote ([o new-value]))}, :protocol cljs.core/IReset, :name cljs.core/-reset!, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([o new-value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 695, :end-line 697, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o new-value])), :doc "Sets the value of o to new-value."}, -rest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 455, :column 9, :end-line 455, :end-column 14, :tag clj, :protocol cljs.core/ISeq, :doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()", :arglists (quote ([coll]))}, :protocol cljs.core/ISeq, :name cljs.core/-rest, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 451, :ret-tag clj, :end-line 455, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()"}, nil-iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3454, :column 7, :end-line 3454, :end-column 15, :arglists (quote ([]))}, :name cljs.core/nil-iter, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3454, :end-line 3454, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, pr-writer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8657, :column 8, :end-line 8657, :end-column 17, :private true, :arglists (quote ([obj writer opts])), :doc "Prefer this to pr-seq, because it makes the printing function\n   configurable, allowing efficient implementations such as appending\n   to a StringBuffer."}, :private true, :name cljs.core/pr-writer, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([obj writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8657, :end-line 8657, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts])), :doc "Prefer this to pr-seq, because it makes the printing function\n   configurable, allowing efficient implementations such as appending\n   to a StringBuffer."}, false? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1934, :column 16, :end-line 1934, :end-column 22, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is the value false, false otherwise."}, :name cljs.core/false?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1934, :ret-tag boolean, :end-line 1934, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is the value false, false otherwise."}, RangedIterator {:num-fields 6, :protocols #{cljs.core/Object}, :name cljs.core/RangedIterator, :file "cljs/core.cljs", :end-column 24, :type true, :column 10, :line 4646, :record false, :end-line 4646, :skip-protocol-flag nil}, *print-readably* {:name cljs.core/*print-readably*, :file "cljs/core.cljs", :line 72, :column 1, :end-line 78, :end-column 19, :dynamic true, :doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true", :meta {:file "cljs/core.cljs", :line 78, :column 3, :end-line 78, :end-column 19, :dynamic true, :doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true"}}, ints {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2430, :column 7, :end-line 2430, :end-column 11, :arglists (quote ([x]))}, :name cljs.core/ints, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2430, :end-line 2430, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, some-fn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4089, :column 7, :end-line 4089, :end-column 14, :arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([p] [p1 p2] [p1 p2 p3]), :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/some-fn, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([p] [p1 p2] [p1 p2 p3]), :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :arglists-meta (nil nil nil nil)}, :method-params ([p] [p1 p2] [p1 p2 p3]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 4089, :end-line 4089, :max-fixed-arity 3, :fn-var true, :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates."}, demunge-pattern {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9819, :column 8, :end-line 9819, :end-column 23, :private true, :arglists (quote ([]))}, :private true, :name cljs.core/demunge-pattern, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9819, :end-line 9819, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, *flush-on-newline* {:name cljs.core/*flush-on-newline*, :file "cljs/core.cljs", :line 58, :column 1, :end-line 63, :end-column 21, :dynamic true, :doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true.", :meta {:file "cljs/core.cljs", :line 63, :column 3, :end-line 63, :end-column 21, :dynamic true, :doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true."}}, to-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3145, :column 7, :end-line 3145, :end-column 15, :arglists (quote ([s])), :doc "Naive impl of to-array as a start."}, :name cljs.core/to-array, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3145, :end-line 3145, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Naive impl of to-array as a start."}, build-subvec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5080, :column 8, :end-line 5080, :end-column 20, :private true, :arglists (quote ([meta v start end __hash]))}, :private true, :name cljs.core/build-subvec, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([meta v start end __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5080, :end-line 5080, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta v start end __hash]))}, Namespace {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object}, :name cljs.core/Namespace, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 9876, :record false, :end-line 9876, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash}}, list? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2855, :column 16, :end-line 2855, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x implements IList"}, :name cljs.core/list?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2855, :ret-tag boolean, :end-line 2855, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x implements IList"}, tree-map-remove {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7365, :column 8, :end-line 7365, :end-column 23, :private true, :arglists (quote ([comp tree k found]))}, :private true, :name cljs.core/tree-map-remove, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([comp tree k found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7365, :end-line 7365, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp tree k found]))}, HashCollisionNode {:num-fields 4, :protocols #{cljs.core/Object}, :name cljs.core/HashCollisionNode, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 6388, :record false, :end-line 6388, :skip-protocol-flag nil}, array? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 170, :column 16, :end-line 170, :end-column 22, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript array."}, :name cljs.core/array?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 170, :ret-tag boolean, :end-line 170, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript array."}, prefers* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9329, :column 8, :end-line 9329, :end-column 16, :private true, :arglists (quote ([x y prefer-table]))}, :private true, :name cljs.core/prefers*, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x y prefer-table]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9329, :end-line 9329, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x y prefer-table]))}, clone {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1012, :column 7, :end-line 1012, :end-column 12, :arglists (quote ([value])), :doc "Clone the supplied value which must implement ICloneable."}, :name cljs.core/clone, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1012, :end-line 1012, :max-fixed-arity 1, :fn-var true, :arglists (quote ([value])), :doc "Clone the supplied value which must implement ICloneable."}, scan-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5411, :column 8, :end-line 5411, :end-column 18, :private true, :arglists (quote ([incr k array]))}, :private true, :name cljs.core/scan-array, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([incr k array]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5411, :end-line 5411, :max-fixed-arity 3, :fn-var true, :arglists (quote ([incr k array]))}, demunge {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9869, :column 7, :end-line 9869, :end-column 14, :arglists (quote ([name]))}, :name cljs.core/demunge, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9869, :end-line 9869, :max-fixed-arity 1, :fn-var true, :arglists (quote ([name]))}, bit-not {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2491, :column 7, :end-line 2491, :end-column 14, :arglists (quote ([x])), :doc "Bitwise complement"}, :name cljs.core/bit-not, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2491, :end-line 2491, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Bitwise complement"}, quote-string {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8580, :column 17, :end-line 8580, :end-column 29, :private true, :arglists (quote ([s]))}, :private true, :name cljs.core/quote-string, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8580, :end-line 8580, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, byte {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2305, :column 15, :end-line 2305, :end-column 19, :tag number, :arglists (quote ([x]))}, :name cljs.core/byte, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2305, :ret-tag number, :end-line 2305, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, max {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2291, :column 15, :end-line 2291, :end-column 18, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns the greatest of the nums.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/max, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2291, :ret-tag number, :end-line 2291, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns the greatest of the nums."}, IComparable {:meta {:file "cljs/core.cljs", :line 662, :column 14, :end-line 662, :end-column 25, :doc "Protocol for values that can be compared.", :protocol-symbol true, :protocol-info {:methods {-compare [[x y]]}}}, :protocol-symbol true, :name cljs.core/IComparable, :file "cljs/core.cljs", :end-column 25, :column 1, :line 662, :protocol-info {:methods {-compare [[x y]]}}, :info nil, :end-line 662, :impls #{js/Date cljs.core/Keyword cljs.core/Subvec cljs.core/PersistentVector cljs.core/Symbol cljs.core/UUID}, :doc "Protocol for values that can be compared."}, == {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2528, :column 16, :end-line 2528, :end-column 18, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/==, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2528, :ret-tag boolean, :end-line 2528, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined."}, parents {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9244, :column 7, :end-line 9244, :end-column 14, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}}, :name cljs.core/parents, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}, :method-params ([tag] [h tag]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9244, :end-line 9244, :max-fixed-arity 2, :fn-var true, :arglists ([tag] [h tag]), :doc "Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy"}, count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1546, :column 7, :end-line 1546, :end-column 12, :arglists (quote ([coll])), :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps"}, :name cljs.core/count, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1546, :end-line 1546, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps"}, -disjoin! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 659, :column 9, :end-line 659, :end-column 18, :tag clj, :protocol cljs.core/ITransientSet, :doc "Returns tcoll without v.", :arglists (quote ([tcoll v]))}, :protocol cljs.core/ITransientSet, :name cljs.core/-disjoin!, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([tcoll v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 657, :ret-tag clj, :end-line 659, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll v])), :doc "Returns tcoll without v."}, *loaded-libs* {:name cljs.core/*loaded-libs*, :file "cljs/core.cljs", :line 116, :column 1, :end-line 116, :end-column 33, :dynamic true, :meta {:file "cljs/core.cljs", :line 116, :column 20, :end-line 116, :end-column 33, :dynamic true}}, ->TransientHashMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6771, :column 10, :end-line 6771, :end-column 26, :protocols #{cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :factory :positional, :arglists (quote ([edit root count has-nil? nil-val]))}, :protocols #{cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientHashMap, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([edit root count has-nil? nil-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6771, :end-line 6771, :max-fixed-arity 5, :fn-var true, :arglists (quote ([edit root count has-nil? nil-val])), :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, array-index-of-symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5614, :column 8, :end-line 5614, :end-column 30, :private true, :arglists (quote ([arr k]))}, :private true, :name cljs.core/array-index-of-symbol?, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5614, :end-line 5614, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, ArrayChunk {:meta {:file "cljs/core.cljs", :line 3006, :column 10, :end-line 3006, :end-column 20, :declared true}, :num-fields 3, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :name cljs.core/ArrayChunk, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 3025, :record false, :declared true, :end-line 3025, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}}, sorted-map-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7586, :column 7, :end-line 7586, :end-column 20, :arglists (quote ([comparator & keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keyvals)], :arglists ([comparator & keyvals]), :arglists-meta (nil)}}, :name cljs.core/sorted-map-by, :variadic true, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keyvals)], :arglists ([comparator & keyvals]), :arglists-meta (nil)}, :method-params [(comparator keyvals)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 7586, :end-line 7586, :max-fixed-arity 1, :fn-var true, :arglists ([comparator & keyvals]), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator."}, apply {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3379, :column 7, :end-line 3379, :end-column 12, :arglists (quote ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args])), :doc "Applies fn f to the argument list formed by prepending intervening arguments to args.", :top-fn {:variadic true, :max-fixed-arity 5, :method-params ([f args] [f x args] [f x y args] [f x y z args]), :arglists ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/apply, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 5, :method-params ([f args] [f x args] [f x y args] [f x y z args]), :arglists ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]), :arglists-meta (nil nil nil nil nil)}, :method-params ([f args] [f x args] [f x y args] [f x y z args]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 3379, :end-line 3379, :max-fixed-arity 5, :fn-var true, :arglists ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]), :doc "Applies fn f to the argument list formed by prepending intervening arguments to args."}, get-global-hierarchy {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9216, :column 8, :end-line 9216, :end-column 28, :private true, :arglists (quote ([]))}, :private true, :name cljs.core/get-global-hierarchy, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9216, :end-line 9216, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, add-to-string-hash-cache {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 816, :column 7, :end-line 816, :end-column 31, :arglists (quote ([k]))}, :name cljs.core/add-to-string-hash-cache, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 816, :end-line 816, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, clj->js {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9096, :column 7, :end-line 9096, :end-column 14, :arglists (quote ([x])), :doc "Recursively transforms ClojureScript values to JavaScript.\nsets/vectors/lists become Arrays, Keywords and Symbol become Strings,\nMaps become Objects. Arbitrary keys are encoded to by key->js."}, :name cljs.core/clj->js, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9096, :end-line 9096, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Recursively transforms ClojureScript values to JavaScript.\nsets/vectors/lists become Arrays, Keywords and Symbol become Strings,\nMaps become Objects. Arbitrary keys are encoded to by key->js."}, TransientArrayMap {:meta {:file "cljs/core.cljs", :line 5672, :column 10, :end-line 5672, :end-column 27, :declared true}, :num-fields 3, :protocols #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientArrayMap, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 5929, :record false, :declared true, :end-line 5929, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, ->TransientVector {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5157, :column 10, :end-line 5157, :end-column 25, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :factory :positional, :arglists (quote ([cnt shift root tail]))}, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientVector, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([cnt shift root tail]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5157, :end-line 5157, :max-fixed-arity 4, :fn-var true, :arglists (quote ([cnt shift root tail])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}}, IChunkedNext {:meta {:file "cljs/core.cljs", :line 680, :column 14, :end-line 680, :end-column 26, :doc "Protocol for accessing the chunks of a collection.", :protocol-symbol true, :protocol-info {:methods {-chunked-next [[coll]]}}}, :protocol-symbol true, :name cljs.core/IChunkedNext, :file "cljs/core.cljs", :end-column 26, :column 1, :line 680, :protocol-info {:methods {-chunked-next [[coll]]}}, :info nil, :end-line 680, :impls #{cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :doc "Protocol for accessing the chunks of a collection."}, interpose {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4308, :column 7, :end-line 4308, :end-column 16, :arglists (quote ([sep] [sep coll])), :doc "Returns a lazy seq of the elements of coll separated by sep", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([sep] [sep coll]), :arglists ([sep] [sep coll]), :arglists-meta (nil nil)}}, :name cljs.core/interpose, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([sep] [sep coll]), :arglists ([sep] [sep coll]), :arglists-meta (nil nil)}, :method-params ([sep] [sep coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4308, :end-line 4308, :max-fixed-arity 2, :fn-var true, :arglists ([sep] [sep coll]), :doc "Returns a lazy seq of the elements of coll separated by sep"}, ->BlackNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7042, :column 10, :end-line 7042, :end-column 19, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :factory :positional, :arglists (quote ([key val left right __hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->BlackNode, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([key val left right __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7042, :end-line 7042, :max-fixed-arity 5, :fn-var true, :arglists (quote ([key val left right __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, deref {:name cljs.core/deref, :file "cljs/core.cljs", :line 6010, :column 1, :end-line 6010, :end-column 78, :declared true, :meta {:file "cljs/core.cljs", :line 6010, :column 73, :end-line 6010, :end-column 78, :declared true}}, pv-aget {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4554, :column 8, :end-line 4554, :end-column 15, :private true, :arglists (quote ([node idx]))}, :private true, :name cljs.core/pv-aget, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([node idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4554, :end-line 4554, :max-fixed-arity 2, :fn-var true, :arglists (quote ([node idx]))}, assoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1703, :column 7, :end-line 1703, :end-column 12, :arglists (quote ([coll k v] [coll k v & kvs])), :doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([coll k v]), :arglists ([coll k v] [coll k v & kvs]), :arglists-meta (nil nil)}}, :name cljs.core/assoc, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([coll k v]), :arglists ([coll k v] [coll k v & kvs]), :arglists-meta (nil nil)}, :method-params ([coll k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1703, :end-line 1703, :max-fixed-arity 3, :fn-var true, :arglists ([coll k v] [coll k v & kvs]), :doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index."}, transient {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3308, :column 7, :end-line 3308, :end-column 16, :arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time."}, :name cljs.core/transient, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3308, :end-line 3308, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time."}, -disjoin {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 499, :column 9, :end-line 499, :end-column 17, :tag clj, :protocol cljs.core/ISet, :doc "Returns a new collection of coll that does not contain v.", :arglists (quote ([coll v]))}, :protocol cljs.core/ISet, :name cljs.core/-disjoin, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 497, :ret-tag clj, :end-line 499, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll v])), :doc "Returns a new collection of coll that does not contain v."}, chunk-cons {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3121, :column 7, :end-line 3121, :end-column 17, :arglists (quote ([chunk rest]))}, :name cljs.core/chunk-cons, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([chunk rest]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3121, :end-line 3121, :max-fixed-arity 2, :fn-var true, :arglists (quote ([chunk rest]))}, ArrayIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/ArrayIter, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 3473, :record false, :end-line 3473, :skip-protocol-flag nil}, comparator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9731, :column 7, :end-line 9731, :end-column 17, :arglists (quote ([pred])), :doc "Returns an JavaScript compatible comparator based upon pred."}, :name cljs.core/comparator, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pred]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9731, :end-line 9731, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pred])), :doc "Returns an JavaScript compatible comparator based upon pred."}, sorted-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7577, :column 7, :end-line 7577, :end-column 17, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name cljs.core/sorted-map, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 7577, :end-line 7577, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings."}, drop-while {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4237, :column 7, :end-line 4237, :end-column 17, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name cljs.core/drop-while, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4237, :end-line 4237, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided."}, IWriter {:meta {:file "cljs/core.cljs", :line 596, :column 14, :end-line 596, :end-column 21, :doc "Protocol for writing. Currently only implemented by StringBufferWriter.", :protocol-symbol true, :protocol-info {:methods {-write [[writer s]], -flush [[writer]]}}}, :protocol-symbol true, :name cljs.core/IWriter, :file "cljs/core.cljs", :end-column 21, :column 1, :line 596, :protocol-info {:methods {-write [[writer s]], -flush [[writer]]}}, :info nil, :end-line 596, :impls #{cljs.core/StringBufferWriter}, :doc "Protocol for writing. Currently only implemented by StringBufferWriter."}, KeySeq {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/KeySeq, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 7596, :record false, :end-line 7596, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, realized? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8996, :column 16, :end-line 8996, :end-column 25, :tag boolean, :arglists (quote ([d])), :doc "Returns true if a value has been produced for a delay or lazy sequence."}, :name cljs.core/realized?, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8996, :ret-tag boolean, :end-line 8996, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([d])), :doc "Returns true if a value has been produced for a delay or lazy sequence."}, *print-fn* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 50, :column 3, :end-line 50, :end-column 13, :doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.", :dynamic true}, :name cljs.core/*print-fn*, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([_]), :protocol-impl nil, :arglists-meta (), :column 1, :dynamic true, :line 46, :end-line 50, :max-fixed-arity 1, :fn-var true, :arglists nil, :doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed."}, compare {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2014, :column 15, :end-line 2014, :end-column 22, :tag number, :arglists (quote ([x y])), :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object."}, :name cljs.core/compare, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2014, :ret-tag number, :end-line 2014, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x y])), :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object."}, complement {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3725, :column 16, :end-line 3725, :end-column 26, :tag boolean, :arglists (quote ([f])), :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value."}, :name cljs.core/complement, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3725, :ret-tag boolean, :end-line 3725, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value."}, lookup-sentinel {:name cljs.core/lookup-sentinel, :file "cljs/core.cljs", :line 1932, :column 1, :end-line 1932, :end-column 31, :private true, :meta {:file "cljs/core.cljs", :line 1932, :column 16, :end-line 1932, :end-column 31, :private true}}, -assoc! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 641, :column 9, :end-line 641, :end-column 16, :tag clj, :protocol cljs.core/ITransientAssociative, :doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it.", :arglists (quote ([tcoll key val]))}, :protocol cljs.core/ITransientAssociative, :name cljs.core/-assoc!, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([tcoll key val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 639, :ret-tag clj, :end-line 641, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([tcoll key val])), :doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it."}, *print-dup* {:name cljs.core/*print-dup*, :file "cljs/core.cljs", :line 88, :column 1, :end-line 94, :end-column 14, :dynamic true, :doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false.", :meta {:file "cljs/core.cljs", :line 94, :column 3, :end-line 94, :end-column 14, :dynamic true, :doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false."}}, string-iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3470, :column 7, :end-line 3470, :end-column 18, :arglists (quote ([x]))}, :name cljs.core/string-iter, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3470, :end-line 3470, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, -key->js {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9081, :column 4, :end-line 9081, :end-column 12, :protocol cljs.core/IEncodeJS, :doc "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)", :arglists (quote ([x]))}, :protocol cljs.core/IEncodeJS, :name cljs.core/-key->js, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9079, :end-line 9081, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)"}, IDeref {:meta {:file "cljs/core.cljs", :line 517, :column 14, :end-line 517, :end-column 20, :doc "Protocol for adding dereference functionality to a reference.", :protocol-symbol true, :protocol-info {:methods {-deref [[o]]}}}, :protocol-symbol true, :name cljs.core/IDeref, :file "cljs/core.cljs", :end-column 20, :column 1, :line 517, :protocol-info {:methods {-deref [[o]]}}, :info nil, :end-line 517, :impls #{cljs.core/Reduced cljs.core/Volatile cljs.core/Delay cljs.core/Var cljs.core/Atom}, :doc "Protocol for adding dereference functionality to a reference."}, sequence {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3669, :column 7, :end-line 3669, :end-column 15, :arglists (quote ([coll] [xform coll] [xform coll & colls])), :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [xform coll]), :arglists ([coll] [xform coll] [xform coll & colls]), :arglists-meta (nil nil nil)}}, :name cljs.core/sequence, :variadic true, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [xform coll]), :arglists ([coll] [xform coll] [xform coll & colls]), :arglists-meta (nil nil nil)}, :method-params ([coll] [xform coll]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 3669, :end-line 3669, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [xform coll] [xform coll & colls]), :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments"}, constantly {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3735, :column 7, :end-line 3735, :end-column 17, :arglists (quote ([x])), :doc "Returns a function that takes any number of arguments and returns x."}, :name cljs.core/constantly, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3735, :end-line 3735, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a function that takes any number of arguments and returns x."}, ->RangedIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4646, :column 10, :end-line 4646, :end-column 24, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([i base arr v start end]))}, :protocols #{cljs.core/Object}, :name cljs.core/->RangedIterator, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([i base arr v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 4646, :end-line 4646, :max-fixed-arity 6, :fn-var true, :arglists (quote ([i base arr v start end])), :skip-protocol-flag nil}, chunked-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4966, :column 7, :end-line 4966, :end-column 18, :arglists (quote ([vec i off] [vec node i off] [vec node i off meta])), :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([vec i off] [vec node i off] [vec node i off meta]), :arglists ([vec i off] [vec node i off] [vec node i off meta]), :arglists-meta (nil nil nil)}}, :name cljs.core/chunked-seq, :variadic false, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([vec i off] [vec node i off] [vec node i off meta]), :arglists ([vec i off] [vec node i off] [vec node i off meta]), :arglists-meta (nil nil nil)}, :method-params ([vec i off] [vec node i off] [vec node i off meta]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 4966, :end-line 4966, :max-fixed-arity 5, :fn-var true, :arglists ([vec i off] [vec node i off] [vec node i off meta])}, ISorted {:meta {:file "cljs/core.cljs", :line 579, :column 14, :end-line 579, :end-column 21, :doc "Protocol for a collection which can represent their items\n  in a sorted manner. ", :protocol-symbol true, :protocol-info {:methods {-sorted-seq [[coll ascending?]], -sorted-seq-from [[coll k ascending?]], -entry-key [[coll entry]], -comparator [[coll]]}}}, :protocol-symbol true, :name cljs.core/ISorted, :file "cljs/core.cljs", :end-column 21, :column 1, :line 579, :protocol-info {:methods {-sorted-seq [[coll ascending?]], -sorted-seq-from [[coll k ascending?]], -entry-key [[coll entry]], -comparator [[coll]]}}, :info nil, :end-line 579, :impls #{cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet}, :doc "Protocol for a collection which can represent their items\n  in a sorted manner. "}, make-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 316, :column 14, :end-line 316, :end-column 24, :tag array, :arglists (quote ([size] [type size])), :doc "Construct a JavaScript array of specified size. Accepts ignored type\n  argument for compatibility with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size] [type size]), :arglists ([size] [type size]), :arglists-meta (nil nil)}}, :name cljs.core/make-array, :variadic false, :file "cljs/core.cljs", :end-column 24, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size] [type size]), :arglists ([size] [type size]), :arglists-meta (nil nil)}, :method-params ([size] [type size]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 316, :ret-tag array, :end-line 316, :max-fixed-arity 2, :tag array, :fn-var true, :arglists ([size] [type size]), :doc "Construct a JavaScript array of specified size. Accepts ignored type\n  argument for compatibility with Clojure."}, shorts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2429, :column 7, :end-line 2429, :end-column 13, :arglists (quote ([x]))}, :name cljs.core/shorts, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2429, :end-line 2429, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, *unchecked-if* {:name cljs.core/*unchecked-if*, :file "cljs/core.cljs", :line 18, :column 1, :end-line 18, :end-column 20, :meta {:file "cljs/core.cljs", :line 18, :column 6, :end-line 18, :end-column 20}}, ->RSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1427, :column 10, :end-line 1427, :end-column 14, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([ci i meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->RSeq, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([ci i meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1427, :end-line 1427, :max-fixed-arity 3, :fn-var true, :arglists (quote ([ci i meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, enable-console-print! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 127, :column 7, :end-line 127, :end-column 28, :arglists (quote ([])), :doc "Set *print-fn* to console.log"}, :name cljs.core/enable-console-print!, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 127, :end-line 127, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Set *print-fn* to console.log"}, -flush {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 600, :column 4, :end-line 600, :end-column 10, :protocol cljs.core/IWriter, :doc "Flush writer.", :arglists (quote ([writer]))}, :protocol cljs.core/IWriter, :name cljs.core/-flush, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([writer]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 596, :end-line 600, :max-fixed-arity 1, :fn-var true, :arglists (quote ([writer])), :doc "Flush writer."}, completing {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2179, :column 7, :end-line 2179, :end-column 17, :arglists (quote ([f] [f cf])), :doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f cf]), :arglists ([f] [f cf]), :arglists-meta (nil nil)}}, :name cljs.core/completing, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f cf]), :arglists ([f] [f cf]), :arglists-meta (nil nil)}, :method-params ([f] [f cf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2179, :end-line 2179, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f cf]), :doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument."}, unchecked-negate-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2379, :column 7, :end-line 2379, :end-column 27, :arglists (quote ([x]))}, :name cljs.core/unchecked-negate-int, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2379, :end-line 2379, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, ->PersistentVector {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4668, :column 10, :end-line 4668, :end-column 26, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta cnt shift root tail __hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->PersistentVector, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([meta cnt shift root tail __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 4668, :end-line 4668, :max-fixed-arity 6, :fn-var true, :arglists (quote ([meta cnt shift root tail __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, equiv-sequential {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2588, :column 8, :end-line 2588, :end-column 24, :private true, :arglists (quote ([x y])), :doc "Assumes x is sequential. Returns true if x equals y, otherwise\n  returns false."}, :private true, :name cljs.core/equiv-sequential, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2588, :end-line 2588, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Assumes x is sequential. Returns true if x equals y, otherwise\n  returns false."}, hash-unordered-coll {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1159, :column 15, :end-line 1159, :end-column 34, :tag number, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms."}, :name cljs.core/hash-unordered-coll, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1159, :ret-tag number, :end-line 1159, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms."}, repeat {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4273, :column 7, :end-line 4273, :end-column 13, :arglists (quote ([x] [n x])), :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([x] [n x]), :arglists ([x] [n x]), :arglists-meta (nil nil)}}, :name cljs.core/repeat, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([x] [n x]), :arglists ([x] [n x]), :arglists-meta (nil nil)}, :method-params ([x] [n x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4273, :end-line 4273, :max-fixed-arity 2, :fn-var true, :arglists ([x] [n x]), :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs."}, unchecked-inc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2356, :column 7, :end-line 2356, :end-column 20, :arglists (quote ([x]))}, :name cljs.core/unchecked-inc, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2356, :end-line 2356, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, nthnext {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2556, :column 7, :end-line 2556, :end-column 14, :arglists (quote ([coll n])), :doc "Returns the nth next of coll, (seq coll) when n is 0."}, :name cljs.core/nthnext, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2556, :end-line 2556, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll n])), :doc "Returns the nth next of coll, (seq coll) when n is 0."}, preserving-reduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9001, :column 8, :end-line 9001, :end-column 26, :private true, :arglists (quote ([rf]))}, :private true, :name cljs.core/preserving-reduced, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([rf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9001, :end-line 9001, :max-fixed-arity 1, :fn-var true, :arglists (quote ([rf]))}, get-validator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3987, :column 7, :end-line 3987, :end-column 20, :arglists (quote ([iref])), :doc "Gets the validator-fn for a var/ref/agent/atom."}, :name cljs.core/get-validator, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([iref]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3987, :end-line 3987, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iref])), :doc "Gets the validator-fn for a var/ref/agent/atom."}, StringIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/StringIter, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 3461, :record false, :end-line 3461, :skip-protocol-flag nil}, number? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 177, :column 16, :end-line 177, :end-column 23, :tag boolean, :arglists (quote ([n])), :doc "Returns true if x is a JavaScript number."}, :name cljs.core/number?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 177, :ret-tag boolean, :end-line 177, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if x is a JavaScript number."}, -conj! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 634, :column 9, :end-line 634, :end-column 15, :tag clj, :protocol cljs.core/ITransientCollection, :doc "Adds value val to tcoll and returns tcoll.", :arglists (quote ([tcoll val]))}, :protocol cljs.core/ITransientCollection, :name cljs.core/-conj!, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([tcoll val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 632, :ret-tag clj, :end-line 634, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll val])), :doc "Adds value val to tcoll and returns tcoll."}, ->PersistentArrayMapSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5674, :column 10, :end-line 5674, :end-column 31, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([arr i _meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->PersistentArrayMapSeq, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([arr i _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5674, :end-line 5674, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, chunk-next {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3138, :column 7, :end-line 3138, :end-column 17, :arglists (quote ([s]))}, :name cljs.core/chunk-next, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3138, :end-line 3138, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, ArrayList {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ArrayList, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 8125, :record false, :end-line 8125, :skip-protocol-flag nil}, print-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8734, :column 7, :end-line 8734, :end-column 16, :arglists (quote ([& objs])), :doc "print to a string, returning it", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/print-str, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8734, :end-line 8734, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "print to a string, returning it"}, not-any? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3710, :column 16, :end-line 3710, :end-column 24, :tag boolean, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for any x in coll,\n  else true."}, :name cljs.core/not-any?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3710, :ret-tag boolean, :end-line 3710, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for any x in coll,\n  else true."}, into-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 368, :column 14, :end-line 368, :end-column 24, :tag array, :arglists (quote ([aseq] [type aseq])), :doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([aseq] [type aseq]), :arglists ([aseq] [type aseq]), :arglists-meta (nil nil)}}, :name cljs.core/into-array, :variadic false, :file "cljs/core.cljs", :end-column 24, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([aseq] [type aseq]), :arglists ([aseq] [type aseq]), :arglists-meta (nil nil)}, :method-params ([aseq] [type aseq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 368, :ret-tag array, :end-line 368, :max-fixed-arity 2, :tag array, :fn-var true, :arglists ([aseq] [type aseq]), :doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure."}, -hash {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 557, :column 4, :end-line 557, :end-column 9, :protocol cljs.core/IHash, :doc "Returns the hash code of o.", :arglists (quote ([o]))}, :protocol cljs.core/IHash, :name cljs.core/-hash, :variadic false, :file "cljs/core.cljs", :end-column 9, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 555, :end-line 557, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the hash code of o."}, -dissoc! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 647, :column 9, :end-line 647, :end-column 17, :tag clj, :protocol cljs.core/ITransientMap, :doc "Returns a new transient collection of tcoll without the mapping for key.", :arglists (quote ([tcoll key]))}, :protocol cljs.core/ITransientMap, :name cljs.core/-dissoc!, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([tcoll key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 645, :ret-tag clj, :end-line 647, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll key])), :doc "Returns a new transient collection of tcoll without the mapping for key."}, ->Reduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1220, :column 10, :end-line 1220, :end-column 17, :protocols #{cljs.core/IDeref}, :skip-protocol-flag #{cljs.core/IDeref}, :factory :positional, :arglists (quote ([val]))}, :protocols #{cljs.core/IDeref}, :name cljs.core/->Reduced, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1220, :end-line 1220, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :skip-protocol-flag #{cljs.core/IDeref}}, chunk-buffer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3022, :column 7, :end-line 3022, :end-column 19, :arglists (quote ([capacity]))}, :name cljs.core/chunk-buffer, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([capacity]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3022, :end-line 3022, :max-fixed-arity 1, :fn-var true, :arglists (quote ([capacity]))}, seqable? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1954, :column 16, :end-line 1954, :end-column 24, :tag boolean, :arglists (quote ([s])), :doc "Return true if s satisfies ISeqable"}, :name cljs.core/seqable?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1954, :ret-tag boolean, :end-line 1954, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([s])), :doc "Return true if s satisfies ISeqable"}, symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 870, :column 16, :end-line 870, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a Symbol"}, :name cljs.core/symbol?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 870, :ret-tag boolean, :end-line 870, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a Symbol"}, m3-hash-unencoded-chars {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 782, :column 15, :end-line 782, :end-column 38, :tag number, :arglists (quote ([in]))}, :name cljs.core/m3-hash-unencoded-chars, :variadic false, :file "cljs/core.cljs", :end-column 38, :method-params ([in]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 782, :ret-tag number, :end-line 782, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([in]))}, unchecked-char {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2320, :column 15, :end-line 2320, :end-column 29, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-char, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2320, :ret-tag number, :end-line 2320, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, NeverEquiv {:num-fields 0, :protocols #{cljs.core/IEquiv cljs.core/Object}, :name cljs.core/NeverEquiv, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 5388, :record false, :end-line 5388, :skip-protocol-flag #{cljs.core/IEquiv}}, -invoke {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 391, :column 4, :end-line 391, :end-column 11, :protocol cljs.core/IFn, :doc nil, :arglists (quote ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest])), :top-fn {:variadic false, :max-fixed-arity 22, :method-params ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :arglists-meta (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)}}, :protocol cljs.core/IFn, :name cljs.core/-invoke, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 22, :method-params ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :arglists-meta (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)}, :method-params ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil), :column 1, :line 387, :end-line 391, :max-fixed-arity 22, :fn-var true, :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :doc nil}, coll? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1841, :column 16, :end-line 1841, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x satisfies ICollection"}, :name cljs.core/coll?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1841, :ret-tag boolean, :end-line 1841, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x satisfies ICollection"}, get-in {:protocol-inline nil, :meta {:added "1.2", :file "cljs/core.cljs", :end-column 13, :static true, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([m ks] [m ks not-found]), :arglists ([m ks] [m ks not-found]), :arglists-meta (nil nil)}, :column 7, :line 4474, :end-line 4474, :arglists (quote ([m ks] [m ks not-found])), :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied."}, :added "1.2", :name cljs.core/get-in, :variadic false, :file "cljs/core.cljs", :end-column 13, :static true, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([m ks] [m ks not-found]), :arglists ([m ks] [m ks not-found]), :arglists-meta (nil nil)}, :method-params ([m ks] [m ks not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4474, :end-line 4474, :max-fixed-arity 3, :fn-var true, :arglists ([m ks] [m ks not-found]), :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied."}, fnext {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1497, :column 7, :end-line 1497, :end-column 12, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, :name cljs.core/fnext, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1497, :end-line 1497, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, IList {:meta {:file "cljs/core.cljs", :line 568, :column 14, :end-line 568, :end-column 19, :doc "Marker interface indicating a persistent list", :protocol-symbol true, :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/IList, :file "cljs/core.cljs", :end-column 19, :column 1, :line 568, :protocol-info {:methods {}}, :info nil, :end-line 568, :impls #{cljs.core/Cons cljs.core/EmptyList cljs.core/List}, :doc "Marker interface indicating a persistent list"}, List {:meta {:file "cljs/core.cljs", :line 1318, :column 30, :end-line 1318, :end-column 34, :declared true}, :num-fields 5, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/List, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 2646, :record false, :declared true, :end-line 2646, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -val {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 494, :column 4, :end-line 494, :end-column 8, :protocol cljs.core/IMapEntry, :doc "Returns the value of the map entry.", :arglists (quote ([coll]))}, :protocol cljs.core/IMapEntry, :name cljs.core/-val, :variadic false, :file "cljs/core.cljs", :end-column 8, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 490, :end-line 494, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the value of the map entry."}, bytes {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2427, :column 7, :end-line 2427, :end-column 12, :arglists (quote ([x]))}, :name cljs.core/bytes, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2427, :end-line 2427, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, ->ObjMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5457, :column 10, :end-line 5457, :end-column 16, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :factory :positional, :arglists (quote ([meta keys strobj update-count __hash]))}, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->ObjMap, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([meta keys strobj update-count __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5457, :end-line 5457, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta keys strobj update-count __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, compare-symbols {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 880, :column 8, :end-line 880, :end-column 23, :private true, :arglists (quote ([a b]))}, :private true, :name cljs.core/compare-symbols, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 880, :end-line 880, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, -seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 562, :column 16, :end-line 562, :end-column 20, :tag clj-or-nil, :protocol cljs.core/ISeqable, :doc "Returns a seq of o, or nil if o is empty.", :arglists (quote ([o]))}, :protocol cljs.core/ISeqable, :name cljs.core/-seq, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 560, :ret-tag clj-or-nil, :end-line 562, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([o])), :doc "Returns a seq of o, or nil if o is empty."}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:meta :dup :else :cljs.core/none :validator :default :ns :fallback-impl :flush-on-newline :no-test :descendants :ancestors :readably :more-marker :print-length :ok :parents :alt-impl :keywordize-keys :cljs.core/not-found}, :order [:flush-on-newline :readably :meta :dup :print-length :else :default :validator :cljs.core/not-found :cljs.core/none :more-marker :alt-impl :fallback-impl :keywordize-keys :parents :descendants :ancestors :ok :no-test :ns]}, :doc nil}
